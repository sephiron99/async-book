<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>러스트 비동기 프로그래밍</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_getting_started/01_chapter.html"><strong aria-hidden="true">1.</strong> 시작하며</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_getting_started/02_why_async.html"><strong aria-hidden="true">1.1.</strong> Async가 필요한 이유</a></li><li class="chapter-item expanded "><a href="01_getting_started/03_state_of_async_rust.html"><strong aria-hidden="true">1.2.</strong> 비동기적 러스트 현황</a></li><li class="chapter-item expanded "><a href="01_getting_started/04_async_await_primer.html"><strong aria-hidden="true">1.3.</strong> async/.await 기초</a></li></ol></li><li class="chapter-item expanded "><a href="02_execution/01_chapter.html"><strong aria-hidden="true">2.</strong> 내부 구조: Future와 태스크 실행하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_execution/02_future.html"><strong aria-hidden="true">2.1.</strong> Future 트레잇</a></li><li class="chapter-item expanded "><a href="02_execution/03_wakeups.html"><strong aria-hidden="true">2.2.</strong> Waker로 태스크 깨우기</a></li><li class="chapter-item expanded "><a href="02_execution/04_executor.html"><strong aria-hidden="true">2.3.</strong> 응용: executor 구현하기</a></li><li class="chapter-item expanded "><a href="02_execution/05_io.html"><strong aria-hidden="true">2.4.</strong> Executor와 시스템 입출력</a></li></ol></li><li class="chapter-item expanded "><a href="03_async_await/01_chapter.html"><strong aria-hidden="true">3.</strong> async/await</a></li><li class="chapter-item expanded "><a href="04_pinning/01_chapter.html"><strong aria-hidden="true">4.</strong> 고정하기</a></li><li class="chapter-item expanded "><a href="05_streams/01_chapter.html"><strong aria-hidden="true">5.</strong> 스트림</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_streams/02_iteration_and_concurrency.html"><strong aria-hidden="true">5.1.</strong> 반복과 동시성</a></li></ol></li><li class="chapter-item expanded "><a href="06_multiple_futures/01_chapter.html"><strong aria-hidden="true">6.</strong> 여러개의 future를 동시에 실행하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_multiple_futures/02_join.html"><strong aria-hidden="true">6.1.</strong> join!</a></li><li class="chapter-item expanded "><a href="06_multiple_futures/03_select.html"><strong aria-hidden="true">6.2.</strong> select!</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.3.</strong> TODO: Spawning</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.4.</strong> TODO: Cancellation and Timeouts</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.5.</strong> TODO: FuturesUnordered</a></li></ol></li><li class="chapter-item expanded "><a href="07_workarounds/01_chapter.html"><strong aria-hidden="true">7.</strong> 알아두면 좋을 요령들</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_workarounds/02_err_in_async_blocks.html"><strong aria-hidden="true">7.1.</strong> async 블록 안에서의 ?</a></li><li class="chapter-item expanded "><a href="07_workarounds/03_send_approximation.html"><strong aria-hidden="true">7.2.</strong> Send 추정</a></li><li class="chapter-item expanded "><a href="07_workarounds/04_recursion.html"><strong aria-hidden="true">7.3.</strong> 재귀</a></li><li class="chapter-item expanded "><a href="07_workarounds/05_async_in_traits.html"><strong aria-hidden="true">7.4.</strong> 트레잇 내부의 async</a></li></ol></li><li class="chapter-item expanded "><a href="08_ecosystem/00_chapter.html"><strong aria-hidden="true">8.</strong> 비동기 생태계</a></li><li class="chapter-item expanded "><a href="09_example/00_intro.html"><strong aria-hidden="true">9.</strong> 마지막 프로젝트: HTTP 서버</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09_example/01_running_async_code.html"><strong aria-hidden="true">9.1.</strong> 비동기 코드 실행하기</a></li><li class="chapter-item expanded "><a href="09_example/02_handling_connections_concurrently.html"><strong aria-hidden="true">9.2.</strong> 연결을 동시적으로 처리하기</a></li><li class="chapter-item expanded "><a href="09_example/03_tests.html"><strong aria-hidden="true">9.3.</strong> 서버 테스트하기</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">10.</strong> TODO: I/O</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">10.1.</strong> TODO: AsyncRead and AsyncWrite</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">11.</strong> TODO: Asynchronous Design Patterns: Solutions and Suggestions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">11.1.</strong> TODO: Modeling Servers and the Request/Response Pattern</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">11.2.</strong> TODO: Managing Shared State</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">러스트 비동기 프로그래밍</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/sephiron99/async-book-ko/tree/ko_KR/ko" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#시작하며" id="시작하며">시작하며</a></h1>
<p>러스트로 비동기 프로그래밍하기에 오신 것을 환영합니다. 만약 비동기 러스트 코드를
배우려고 하신다면, 제대로 찾아오셨습니다. 웹서버나 데이터베이스, 또는 운영체제를
만든다면, 이 책이 하드웨어 성능의 대부분을 뽑아낼 수 있는 러스트의 비동기
프로그래밍 방법를 알려드릴 것입니다.</p>
<h2><a class="header" href="#이-책이-다루는-것들" id="이-책이-다루는-것들">이 책이 다루는 것들</a></h2>
<p>이 책은 러스트의 비동기 기능과 라이브러리를 사용하기 위한 종합적이고 최신의
가이드를 초심자와 숙련자 모두에게 제공하고자 합니다. </p>
<ul>
<li>
<p>이 책의 초반에서는 일반적인 비동기 프로그래밍과 러스트만의 비동기 프로그래밍에
대해 소개합니다.</p>
</li>
<li>
<p>중반부에서는 비동기 코드를 작성할 때 사용되는 핵심 기능과 흐름제어 도구들에
대해 논의합니다. 그리고 라이브러리와 어플리케이션에 최고의 성능과 재사용성을
부여하기 위해 필요한 모범답안을 소개합니다.</p>
</li>
<li>
<p>종반부에서는 보다 넓은 비동기 생태계에 대해 설명하고, 보편적인 태스크를
수행하는 방법에 대한 다양한 예제를 제공합니다.</p>
</li>
</ul>
<p>자, 이제 흥미진진한 러스트의 비동기 프로그래밍 세계로 모험을 떠납시다!</p>
<h1><a class="header" href="#왜-비동기가-필요한가" id="왜-비동기가-필요한가">왜 비동기가 필요한가?</a></h1>
<p>우리 모두는 러스트로 빠르고 안전한 소프트웨어를 작성할 수 있음을 잘 알고
있습니다. 반면, 어떻게 해야 비동기 프로그래밍을 통해서도 빠르고 안전한
소프트웨어를 만들 수 있을까요?</p>
<p>비동기 프로그래밍, 줄여서 비동기는 <em>동시적 프로그래밍 모델</em> 중 하나로서, 갈수록
많은 프로그래밍 언어가 지원하고 있습니다.  비동기는 <code>async/await</code> 문법을 통해,
평범한 동기 프로그래밍의 형태와 느낌을 비슷하게 가져가면서도, 적은 수의 운영체제
스레드 위에서 많은 수의 동시적 태스크를 실행할 수 있게 해줍니다.</p>
<h2><a class="header" href="#비동기-vs-다른-동시성-모델" id="비동기-vs-다른-동시성-모델">비동기 vs 다른 동시성 모델</a></h2>
<p>동시적 프로그래밍은 통상적인 절차적 프로그래밍보다 덜 성숙되었고, 덜
&quot;표준화&quot;되었습니다. 그 결과, 우리는 사용하는 언어가 어떤 동시적 프로그래밍
모델을 지원하는 지에 따라 동시성을 다르게 표현합니다.</p>
<p>아래에서 가장 인기있는 동시성 모델에 대해 간단하게 알아보고, 왜 비동기
프로그래밍이 좀더 폭넓은 동시적 프로그래밍 분야에 적합한지 이해해 봅시다. </p>
<ul>
<li><strong>운영체제 스레드</strong>는 프로그래밍 모델에 어떠한 변경도 필요하지 않아 동시성을
표현하기 매우 쉽습니다. 하지만, 스레드들을 동기화 하는 것이 어려울 수 있고,
성능 오버헤드가 큽니다. 스레드풀이 이러한 단점들을 완화해 줄 수 있지만, 대규모
입출력이 필요한 워크로드에 적용하기에는 역부족입니다.</li>
<li><strong>이벤트-드리븐 프로그래밍</strong>은 _콜백_과 연계하여 고성능을 낼 수 있지만, 종종
번잡한 &quot;비선형&quot; 흐름제어가 필요하게 됩니다. 보통 데이터 흐름과 에러 전파를
추적하기 어려워집니다.</li>
<li><strong>코루틴</strong>은 스레드처럼 프로그래밍 모델을 변경할 필요가 없어 사용하기
쉽습니다. 또, 비동기처럼 많은 수의 태스크를 지원할 수도 있습니다. 하지만,
코루틴은 시스템 프로그래밍과 커스텀 런타임 구현에 필요한 저수준의 디테일을
추상화해 버립니다.</li>
<li><strong>행위자 모델</strong>은 분산 시스템과 매우 흡사하게, 모든 동시적 연산을 행위자라는
기본 단위로 나누고, 행위자들이 실패가능한 메시지 전달체계를 통해 통신하게
합니다. 행위자 모델은 효율적으로 구현될 수 있지만, 흐름제어와 재시도 로직과
같은 해결되지 않은 많은 현실적인 문제들이 남아 있습니다.</li>
</ul>
<p>요약하면, 비동기 프로그래밍은 스레드와 코루틴의 인간공학적 이득을 제공하면서도,
러스트 같은 저수준 언어에 적합한 고성능의 구현을 가능하게 해줍니다.</p>
<h2><a class="header" href="#러스트의-비동기-vs-다른-언어의-비동기" id="러스트의-비동기-vs-다른-언어의-비동기">러스트의 비동기 vs 다른 언어의 비동기</a></h2>
<p>비록 비동기 프로그래밍이 많은 언어에서 지원된다고 하더라도, 몇몇 디테일들은
구현에 따라 다릅니다. Rust의 비동기 구현은 몇 가지 측면에서 다른 대다수의
언어들과 다릅니다.</p>
<ul>
<li>러스트에서는 <strong>Future가 불활성이므로</strong> 오직 poll되었을 때에만 진행됩니다.
future를 drop하면 더 이상 진행되지 않습니다.</li>
<li>러스트에서는 <strong>비동기가 제로 코스트이므로</strong> 사용자가 실제 사용한 연산에
대해서만 비용을 지불하면 됩니다. 특히, 힙 할당과 동적 디스패치 없이도 비동기를
사용할 수 있으므로, 성능에 큰 이점이 됩니다.</li>
<li>러스트가 제공하는 <strong>내장 빌트인이 없고</strong>, 대신에 커뮤니티가 관리하는 크레잇을
통해 런타임이 제공됩니다.</li>
<li>러스트에서는 <strong>싱글과 멀티스레드 구현의 런타임</strong>을 모두 지원하며, 각각은
장단점이 있습니다.</li>
</ul>
<h2><a class="header" href="#러스트에서-비동기와-vs-스레드" id="러스트에서-비동기와-vs-스레드">러스트에서 비동기와 vs 스레드</a></h2>
<p>러스트에서 비동기를 대체할 수 있는 첫번째는 선택지는
<a href="https://doc.rust-lang.org/std/thread/"><code>std::thread</code></a>를 이용해 직접적으로
사용하거나 또는 스레드풀을 이용한 간접적으로도 사용할 수 있는 운영체제
스레드입니다.  스레드에서 비동기로 전환하거나 그 반대의 경우에도 보통 많은 양의
리팩토링이 필요합니다. 이 리팩토링 범위에는 구현과 (라이브러리를 만들고 있다면)
노출된 퍼블릭 인터페이스 둘 다 포함됩니다. 그렇기 때문에, 개발초기에 요구사항에
적합한 모델을 제대로 선정하여야 많은 개발 시간을 단축할 수 있습니다.</p>
<p><strong>운영체제 스레드</strong>는 CPU와 메모리 오버헤드를 수반하기 때문에, 적은 수의
태스크에 적합합니다. 스레드를 생성과 전환은 아이들 상태의 스레드도 시스템
자원을 소비하기 때문에 꽤 비쌉니다. 스레드풀 라이브러리는 이 비용들 중 일부만
줄여줄 뿐입니다. 하지만, 스레드를 이용하면 별다른 코드 변경없이 기존의 동기
코드를 재사용할 수 있으므로, 별도의 프로그래밍 모델이 필요 없습니다.  몇몇
운영체제에서는 스레드의 우선순위를 바꿀 수 있어서 장치 드라이버와 다른
지연시간에 민감한 어플리케이션을 만들 때 유용합니다.</p>
<p><strong>비동기</strong>는 CPU와 메모리 오버헤드를 꽤 줄여주는 데, 특히, 서버와 데이터베이스
같은 대량의 입출력에 의존하는 태스크에서 효과가 큽니다. 나머지는 동일하며,
비동기 런타임은 태스크를 다룰 때 스레드보다 적은 비용을 사용하기 때문에,
운영체제 스레드보다 한 자릿수는 더 많은 태스크를 사용할 수 있습니다. 하지만,
비동기 러스트는 상태기계가 비동기 함수로부터 생성되고, 따라서 실행파일마다
비동기 런타임이 포함되어야 하기 때문에, 바이너리 사이즈 증가를 초래합니다.</p>
<p>한 가지 더 말씀드리자면, 비동기 프로그래밍은 스레드보다 <em>더 좋은 것이 아니라</em>
다른 것입니다. 성능 측면에서 굳이 비동기가 필요하지 않다면, 보통 스레드가 보다
간단한 대안이 될 것입니다.</p>
<h3><a class="header" href="#예제-동시적-다운로드" id="예제-동시적-다운로드">예제: 동시적 다운로드</a></h3>
<p>이 예제의 목표는 두 개의 웹 페이지를 동시적으로  다운로드 하는 것입니다.
전형적인 스레드 어플리케이션이라면, 동시성을 위해 스레드를 생성하여야 합니다.</p>
<pre><code class="language-rust ignore">fn get_two_sites() {
    // 태스크에 사용될 두 개의 스레드 생성
    let thread_one = thread::spawn(|| download(&quot;https://www.foo.com&quot;));
    let thread_two = thread::spawn(|| download(&quot;https://www.bar.com&quot;));

    // 두 개의 스레드가 완료될 때까지 기다림
    thread_one.join().expect(&quot;thread one panicked&quot;);
    thread_two.join().expect(&quot;thread two panicked&quot;);
}
</code></pre>
<p>하지만, 웹 페이지를 다운로드는 작은 태스크이므로 스레드를 생성하는 것은 많은
낭비이고, 병목을 일으킬 수 있습니다. 비동기 러스트에서는, 이런 태스크들을 추가
스레드 없이 동시적으로 실행할 수 있습니다.</p>
<pre><code class="language-rust ignore">async fn get_two_sites_async() {
    // 완성될때까지 실행된다면, 웹페이지를 비동기적으로 다운로드 할 두 개의 다른
    // &quot;future&quot;를 만들기
    let future_one = download_async(&quot;https://www.foo.com&quot;);
    let future_two = download_async(&quot;https://www.bar.com&quot;);

    // 두 개의 future를 완성될때까지 동시에 실행하기
    join!(future_one, future_two);
}
</code></pre>
<p>여기서는, 추가적인 스레드를 생성하지 않았습니다. 게다가, 모든 함수 호출들이
정적으로 디스패치되었고, 힙 할당도 일어나지 않았습니다! 하지만, 처음 부분에서
코드를 비동기적으로 작성해야 했는데, 바로 이 책이 여러분에게 도움을 줄
부분입니다.</p>
<h2><a class="header" href="#러스트의-커스텀-동시성-모델" id="러스트의-커스텀-동시성-모델">러스트의 커스텀 동시성 모델</a></h2>
<p>마지막으로, 러스트는 스레드와 비동기 둘 중에 하나를 선택하도록 강요하지
않습니다. 한 어플리케이션에서 두 개의 모델 모두를 사용할 수 있으므로, 여러분이
스레드와 비동기에 복합적으로 의존할 때에 유용할 것입니다. 사실, 여러분은 (구현한
라이브러리만 있다면) 이벤트-드리븐 프로그래밍 같은 또 다른 동시성 모델도 사용할
수 있습니다.</p>
<h1><a class="header" href="#비동기적-러스트-현황" id="비동기적-러스트-현황">비동기적 러스트 현황</a></h1>
<p>비동기 러스트 중 일부는 동기적 러스트와 같은 수준의 안정성을 보장받고 있습니다.
나머지 부분들은 과도기에 있으며 향후 변경될 수 있습니다. 비동기 러스트에서는
아래와 같은 장단점들이 있습니다.</p>
<ul>
<li>전형적인 동시적 워크로드에서 뛰어난 런타임 성능</li>
<li>수명, 고정하기와 같은 러스트의 진보된 특징들과의 보다 빈번한 상호작용</li>
<li>동기, 비동기 코드에 걸쳐, 그리고 서로 다른 비동기 런타임에 걸쳐 보장되는 일부
호환성</li>
<li>비동기 런타임과 언어지원이 발전됨에 따라 가중되는 유지보수 부담</li>
</ul>
<p>요약하면, 비동기 러스트는 사용하기 좀 어려워서 동기적 러스트보다 유지보수 부담이
큽니다만, 최상의 성능을 얻을 수 있습니다.
비동기 러스트의 모든 영역이 지속적으로 발전하고 있으므로, 문제점들은
시간이 갈 수록 완화될 것입니다.</p>
<h2><a class="header" href="#언어-및-라이브러리-지원" id="언어-및-라이브러리-지원">언어 및 라이브러리 지원</a></h2>
<p>비동기 프로그래밍은 러스트가 직접 지원하는 기능이지만, 대부분의 비동기
어플리케이션은 커뮤니티가 주도하는 크레잇들에 의존하고 있습니다.
마찬가지로, 여러분도 러스트 언어 기능과 라이브러리 지원을 복합적으로 사용해야 할 것입니다.</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> 트레잇과
같은 가장 기초적인 트레잇, 타입 그리고 함수는 표준 라이브러리에서 지원합니다.</li>
<li><code>async/await</code> 문법은 러스트 컴파일러가 직접 지원합니다.</li>
<li>수많은 유틸리티 타입, 매크로 그리고 함수들은
<a href="https://docs.rs/futures/"><code>futures</code></a> 크레잇에서 지원합니다. 이것들은 모든
비동기 러스트 어플리케이션에서 사용가능합니다.</li>
<li>비동기 코드, 입출력 그리고 작업 생성은 Tokio와 async-std 같은 &quot;비동기
런타임&quot;에서 제공됩니다. 대부분의 비동기 어플리케이션과 몇몇 비동기 크레잇은
특정 런타임에 의존합니다. 보다 자세한 내용은 <a href="01_getting_started/../08_ecosystem/00_chapter.html">&quot;비동기
생태계&quot;</a> 장을 참조하세요.</li>
</ul>
<p>여러분이 동기적 러스트에서 종종 사용했던 몇몇 러스트 기능들은 비동기
러스트에서는 아직 사용할 수 없습니다. 특히, 트레잇 안에서는 비동기 함수를
선언할 수 없습니다. 이같은 기능을 구현하려면 조금 번잡스러운 우회방법을 사용해야 합니다.</p>
<h2><a class="header" href="#컴파일과-디버깅" id="컴파일과-디버깅">컴파일과 디버깅</a></h2>
<p>비동기 러스트의 컴파일러와 런타임 에러들은 대부분 동기 러스트에서 작동했던
그것들과 같은 방식으로 작동합니다만, 주의할만한 차이점이 몇 개 있습니다.</p>
<h3><a class="header" href="#컴파일-에러" id="컴파일-에러">컴파일 에러</a></h3>
<p>비동기 러스트에서 컴파일 에러는 동기적 러스트에서의 같은 수준의 표준과
동일합니다만, 비동기 러스트가 수명이나 고정하기와 같은 좀더 복잡한 언어 기능을
사용하기 때문에, 이러한 에러가 좀더 빈번하게 나타날 것입니다.</p>
<h3><a class="header" href="#런타임-에러" id="런타임-에러">런타임 에러</a></h3>
<p>컴파일러는 비동기 함수를 맞닥트릴 때마다, 내부적으로 상태기계를 생성합니다.
비동기 러스트의 스택 추적들은 일반적으로 런타임의 함수호출 뿐만 아니라, 이런
상태기계의 세부사항을 포함합니다. 따라서, 스택 추적을 해석할 때도 동기적
러스트에서보다 고려할 것들이 더 있습니다.</p>
<h3><a class="header" href="#새로운-실패-상황들" id="새로운-실패-상황들">새로운 실패 상황들</a></h3>
<p>비동기 러스트에서는 몇가지 참신한 실패 상황들이 발생할 수 있습니다. 예를 들어,
블로킹 함수를 비동기 콘텍스트에서 호출하거나, <code>Future</code> 트레잇을 잘못 구현하는
경우들이 있습니다. 이같은 에러들은 컴파일러나 심지어 유닛 테스트에서도 발견되지
않을 수 있습니다. 이 책의 목표대로 여러분이 내부 컨셉과 구조를 완벽한
이해한다면, 이같은 문제들을 예방하는데 큰 도움이 될 것입니다. </p>
<h2><a class="header" href="#호환성-검토" id="호환성-검토">호환성 검토</a></h2>
<p>비동기와 동기적 코드를 항상 자유롭게 섞을 수 있는 것은 아닙니다. 예를 들어,
동기적 함수에서 비동기 함수를 직접 호출할 수는 없습니다. 동기, 비동기 코드는
서로 다른 디자인 패턴을 추구하는 경향이 있고, 따라서 서로 다른 환경을 고려할 수
밖에 없는 코드들을 섞어서 사용하기는 어렵습니다.</p>
<p>비동기 코드끼리도 항상 자유롭게 섞어 사용할 수 있는 것은 아닙니다. 몇몇 크레잇은
특정한 비동기 런타임에 의존합니다, 보통 그런 경우, 특정한 비동기 런타임은 그런
크레잇들의 의존성 목록에 등재됩니다.</p>
<p>이러한 호환성 이슈들은 여러분의 선택지를 축소시키곤 합니다. 따라서 개발 초기에
어떤 비동기 런타임과 크레잇이 필요한지 충분히 고민하는 것이 좋습니다. 어떤
런타임을 한 번 사용하기 시작하면, 호환성에 대하여 많은 고민을 할 필요가 없을
것입니다.</p>
<h2><a class="header" href="#성능-특성" id="성능-특성">성능 특성</a></h2>
<p>비동기 러스트의 성능은 여러분이 사용하는 비동기 런타임의 구현에 달려 있습니다.
비동기 러스트 어플리케이션에 사용되는 런타임들이 상대적으로 새로울지라도,
대부분의 실제 워크로드에서 매우 잘 작동합니다.</p>
<p>대부분의 비동기 생태계가 <em>멀티 스레딩</em> 런타임을 상정(想定)하였다고
말씀드렸습니다. 이렇게 하면 소위 저렴한 동기화라 불리는 싱글 스레딩 비동기 어플리케이션의 이론상 성능
이득을 맛보기 힘들것입니다. 다른 간과된 용례는 장치 드라이버나 GUI 어플리케이션,
기타 등등에 중요한 <em>지연시간에 민감한 태스크들</em> 입니다. 이러한 태스크들은 적합한
스케쥴링을 위해 런타임에 의존하며, 운영체제 지원에 의존할 때도 있습니다.
향후 이러한 용례를 위한 라이브러리 지원의 향상을 기대하여도 좋을 것입니다.</p>
<h1><a class="header" href="#asyncawait-기초" id="asyncawait-기초"><code>async</code>/<code>.await</code> 기초</a></h1>
<p><code>async</code>/<code>.await</code>는 동기적 코드처럼 보이는 비동기 함수들을 작성하는 데 쓰이는
러스트 내장 도구입니다. <code>async</code>는 코드 블록을 <code>Future</code>라는 트레잇을 구현하는
유한상태기계로 변환해줍니다. 동기적 메소드 안에서 블록하는 함수를 호출한다면
전체 스레드가 블록되지만, <code>Future</code>는 블록되어도 스레드를 잡아놓지 않아 다른
<code>Future</code>가 작동할 수 있습니다.</p>
<p><code>Cargo.toml</code> 파일에 의존성을 추가해 봅시다.</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
</code></pre>
<p>비동기 함수를 만들기 위해, <code>async fn</code> 문법을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn do_something() { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p><code>async fn</code>이 반환하는 값은 한 개의 <code>Future</code> 객체입니다. 코드가 실제로 동작하게
하려면, executor로 <code>Future</code> 객체를 실행해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// `block_on` executor는 제공받은 future가 실행되어 완성될 때까지 현재의
// 스레드를 블록한다. 다른 종류의 executor들은 여러 개의 future를 같은 스레드
// 안에서 스케줄링을 한다던가 하는 식으로 보다 복잡하게 동작한다.
use futures::executor::block_on;

async fn hello_world() {
    println!(&quot;hello, world!&quot;);
}

fn main() {
    let future = hello_world(); // 아무것도 출력되지 않음
    block_on(future); // `future` 가 실행되어 &quot;hello, world!&quot;가 출력됨
}
</code></pre></pre>
<p><code>async fn</code> 안에서 <code>.await</code>을 사용하면 <code>Future</code> 트레잇을 구현한 다른 타입이
완성(예시: 다른 <code>async fn</code>의 출력)될 때까지 기다릴 수 있습니다. <code>block on</code>과
달리, <code>.await</code>는 현재의 스레드를 블록하지 않고, 대신에 이 future가 완성될 때까지
비동기적으로 기다립니다. 이렇게 하면 이 future가 현재 진행될 수 없는 상황에서도
다른 태스크들이 실행될 수 있습니다.</p>
<p>예를 들어, 세 개의 <code>async fn</code>(<code>learn_song</code>, <code>sing_song</code> 그리고 <code>dance</code>)이  있다고
칩시다.</p>
<pre><code class="language-rust ignore">async fn learn_song() -&gt; Song { /* ... */ }
async fn sing_song(song: Song) { /* ... */ }
async fn dance() { /* ... */ }
</code></pre>
<p>노래를 배우고 부르며, 춤을 추기위한 방법 중에 하나는 각각을 수행할 때마다
블록하는 것입니다.</p>
<pre><code class="language-rust ignore">fn main() {
    let song = block_on(learn_song());
    block_on(sing_song(song));
    block_on(dance());
}
</code></pre>
<p>그러나, 이 방법으로는 최선의 성능을 낼 수 없습니다. 오직 한 번에 한 가지만
한다구요! 우리가 노래를 부르기 전에 먼저 노래를 배워야 하는 것은 맞지만, 춤은
노래를 배우거나 부르면서도 출 수 있습니다. 이를 위해, 우리는 동시에 수행될 수
있는 두 개의 다른 <code>async fn</code>을 만들면 됩니다.</p>
<pre><code class="language-rust ignore">async fn learn_and_sing() {
    // 노래를 부르기 전에 노래를 배울 때까지 기다림.
    // 스레드를 블록하지 않기 위해 `block_on` 대신에 `.await`을 사용한다. 이렇게
    // 하면, `춤`을 동시에 출 수 있다.
    let song = learn_song().await;
    sing_song(song).await;
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    // `join!`은 `.await`와 비슷하지만 여러 개의 future를 동시에 기다릴 수 있다.
    // `learn_and_sing` future에서 일시적으로 블록되었더라도, `dance` future는
    // 현재의 스레드를 가져올 것이다. `dance`가 블록되면, `learn_and_sing`은 다시
    // 스레드를 가져올 수 있다. 둘 다 블록되면, `async_main`이 블록되고,
    // executor에게 스레드를 양보할 것이다.
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}
</code></pre>
<p>이 예제에서, 노래 배우기는 노래 부르기보다 먼저 동작해야 하지만, 노래 배우기와
부르기는 춤추기와 같은 시간에 동작할 수 있습니다. 만약 <code>learn_and_sing</code>안에서
<code>learn_song().await</code>말고, <code>block_on(learn_song())</code>을 사용했다면, 해당
스레드는 <code>learn_song</code>이 동작하는 동안에는 아무것도 할 수 없었을 것이고, 그렇다면
춤추기를 노래와 동시에 수행할 수 없었을 것입니다. 하지만 우리는 <code>learn_song</code>
future를 <code>.await</code>함으로써, <code>learn_song</code>이 블록되었을지라도 다른 태스크들이 현재의
스래드에서 실행되게 할 수 있습니다. 이 방법으로, 여러개의 future를 한 개의
스레드에서 동시에 실행하여 완성할 수 있습니다.</p>
<h1><a class="header" href="#내부-구조-future와-태스크-실행하기" id="내부-구조-future와-태스크-실행하기">내부 구조: <code>Future</code>와 태스크 실행하기</a></h1>
<p>이 장에서는, <code>Future</code>와 비동기 태스크들을 스케쥴링하는 세부적인 구조에 대해 다룰
것입니다.  만약 <code>Future</code>를 단순히 사용하는 방법에만 관심이 있고, <code>Future</code>가
작동하는 세부 원리에 대해서는 관심이 없다면, <code>async</code> / <code>await</code> 장으로 건너뛰셔도
됩니다. 하지만, 이 장에서 다루는 여러 내용들은 <code>async</code> / <code>await</code>의 작동방식을
이해하고, <code>async</code> / <code>await</code> 코드의 런타임과 성능요인을 이해하며, 새로운 비동기
primitive을 만드는 데 도움이될 것입니다. 만약, 이 장을 건너뛰기로 하셨다면,
나중에라도 읽기 위해 북마크해놓으실 것을 추천합니다.</p>
<p>자, 이제 본격적으로 <code>Future</code>에 대해 알아봅시다.</p>
<h1><a class="header" href="#future-트레잇" id="future-트레잇"><code>Future</code> 트레잇</a></h1>
<p><code>Future</code> 트레잇은 러스트 비동기 프로그래밍의 핵심입니다. <code>Future</code>는 비동기
연산의 일종으로, 한 개의 값을 산출할 수 있습니다(그 값이 <code>()</code>같은 빈
값일지라도요). <em>단순화된</em> 버전의 future 트레잇은 다음과 같은 형태라고 할 수
있습니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SimpleFuture {
    type Output;
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>Future는 <code>poll</code> 함수를 호출하면 진행됩니다. future가 완성될 때까지, <code>poll</code> 함수는 
그때그때 가능한 만큼 future를 구동시킬 것입니다. 만약 Future가 완성된다면, Future는
<code>Poll::Ready(result)</code>를 반환합니다. Future가 아직 완성될 수 없다면, Future는
<code>Poll::Pending</code>을 반환하고, <code>Future</code>가 좀 더 진행될 때를 대비하여 <code>wake()</code>함수가
호출될 수 있게 준비합니다. <code>wake()</code> 함수가 호출되었을 때, 해당 <code>Future</code>를
구동(drive)하는 executor는 <code>poll</code>을 다시 호출하여 <code>Future</code>가 더 진행될 수 있게
합니다.</p>
<p><code>wake()</code>가 없다면, executor는 어떤 future가 진행할 준비가 되었는지를 알 방법이
없어서, 아마 끊임없이 모든 future를 폴링(polling)해야만 할 것입니다. <code>wake()</code>
덕분에, executor는 어떤 future가 <code>poll</code> 될 수 있는지 정확히 알 수 있습니다.</p>
<p>예를 들어, 데이터를 제공할 준비가 됐는지 알 수 없는 소켓에서 데이터를 읽어야
하는 사례를 생각해봅시다. 만약 데이터가 있다면, 우리는 데이터를 읽어들여서
<code>Poll::Ready(data)</code>를 반환하면 됩니다. 하지만, 데이터가 준비되지 않았다면,
future는 블록될 것이고, 더 이상 진행할 수 없을 것입니다. 데이터가 준비되지
않았을 때에는, <code>wake</code>를 등록하여 소켓에 데이터가 준비되었을 때 <code>wake</code>가 호출될
수 있도록 합니다. 이렇게 등록하면 executor에게 우리의 future가 진행될 준비가
되었음을 알릴 수 있습니다. 간단한 <code>SocketRead</code> future는 다음과 같은 형태라고 할
수 있습니다.</p>
<pre><code class="language-rust ignore">pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // 소켓에 데이터가 준비됨-- 버퍼에 읽어 들이고 버퍼를 반환
            Poll::Ready(self.socket.read_buf())
        } else {
            // 소켓에 아직 데이터가 준비되지 않음
            //
            // 데이터가 준비되면 `wake`가 호출될 수 있도록 조치함.
            // 데이터가 준비되면, `wake`가 호출되고, 이 `Future`의 사용자는
            // `poll`을 다시 호출하여 데이터를 읽을 수 있음을 알게 된다.
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p>여러 <code>Future</code>에 대한 아래와 같은 구조는 여러 개의 비동기 동작들을 중간 할당 없이
한꺼번에 조율할 수 있게 해줍니다. 여러개의 future를 한 번에 실행하거나
연쇄실행하는 방식은 다음과 같이 할당 없는 상태기계로 구현될 수 있습니다.</p>
<pre><code class="language-rust ignore">/// 두 개의 다른 future를 실행하여 동시에 완성하는 SimpleFuture.
///
/// 각각의 future를 `poll`하는 호출이 교차로 이루어질 수 있어, 각 future가
/// 각자의 페이스대로 진행될 수 있게 해준다. 이를 통해 동시성을 얻을 수 있다.
pub struct Join&lt;FutureA, FutureB&gt; {
    // 각 필드는 완성될 때까지 실행되어야 하는 future를 한 개씩 갖을 수 있다.
    // 만약, future가 이미 완성되었다면, 그 필드는 `None`으로 설정된다.
    // 이를 통해, future가 완성된 이후에 폴링하는 `Future` trait 규칙 위반을
    // 예방할 수 있다.
    a: Option&lt;FutureA&gt;,
    b: Option&lt;FutureB&gt;,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for Join&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        // future `a`를 완성하려고 시도함.
        if let Some(a) = &amp;mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // future `b`를 완성하려고 시도함.
        if let Some(b) = &amp;mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() &amp;&amp; self.b.is_none() {
            // 두 future 모두 완성되었음-- 성공적으로 반환함
            Poll::Ready(())
        } else {
            // 하나 또는 두 개의 future가 `Poll::Pending`을 반환하므로, 아직
            // 해야 할 태스크가 남아 있다. future(들)은 진행이 가능할 때
            // `wake()`를 호출할 것이다.
            Poll::Pending
        }
    }
}
</code></pre>
<p>위 예제는 여러개의 future가 각각에 대한 할당 없이도 어떻게 동시에 실행 될 수
있는지 보여줍니다. 이는 보다 효율적인 비동기 프로그램입니다. 마찬가지로, 순서가
있는 여러개의 future는 아래와 같이 한 개 한 개 씩 실행될 수 있습니다.</p>
<pre><code class="language-rust ignore">/// 두 개의 future가 완성될 때까지 순차적으로 실행하는 SimpleFuture
//
// 주의: 이 간단한 예제의 취지에 맞도록, `AndThenFut`은 첫 번째와 두 번째
// future 둘 다 생성시에 활성화되었다고 가정한다. 진짜 `AndThen` 조합자는
// `get_breakfast.and_then(|food| eat(food))`처럼 첫 번째 future의
// 결과에 따라 두 번째 future를 만들 수 있다.
pub struct AndThenFut&lt;FutureA, FutureB&gt; {
    first: Option&lt;FutureA&gt;,
    second: FutureB,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for AndThenFut&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if let Some(first) = &amp;mut self.first {
            match first.poll(wake) {
                // 첫 번째 future가 완성되었다. 첫 번째를 제거하고 두 번째
                // future를 시작한다!
                Poll::Ready(()) =&gt; self.first.take(),
                // 첫 번째 future도 완성되지 못했다.
                Poll::Pending =&gt; return Poll::Pending,
            };
        }
        // 이제 첫 번재 future가 완성되었으니, 두 번째 future를 완성하려고
        // 시도한다.
        self.second.poll(wake)
    }
}
</code></pre>
<p>위의 예제들은 <code>Future</code> 트레잇이 여러개의 할당된 객체나 반복중첩된(deeply nested)
콜백 없이 비동기 흐름 제어를 구현하는 방법을 보여줍니다. 기본적인 흐름제어에
대한 설명은 이쯤에서 마치고, 진짜 <code>Future</code> 트레잇은 실제로 어떻게 생겼고, 무엇이 다른지
살펴봅시다.</p>
<pre><code class="language-rust ignore">trait Future {
    type Output;
    fn poll(
        // `&amp;mut self`에서 `Pin&lt;&amp;mut Self&gt;`로 변화되었음:
        self: Pin&lt;&amp;mut Self&gt;,
        // `wake: fn()`에서 `cx: &amp;mut Context&lt;'_&gt;`로 변화되었음:
        cx: &amp;mut Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre>
<p>여러분이 확인하게 된 첫 번째 변화는 <code>self</code> 타입이 더 이상 <code>&amp;mut Self</code>가 아니고,
<code>Pin&lt;&amp;mut Self&gt;</code>로 바뀌었다는 점입니다. <a href="02_execution/../04_pinning/01_chapter.html">다른 장</a>에서 고정하기에
대해 더 다루겠지만, 지금은 이동불가한 future를 만들 수 있게 해준다는 점만 알아
두십시오. 이동불가한 객체는 <code>struct MyFut { a: i32, ptr_to_a: *const i32 }</code> 처럼
필드에 포인터를 저장할 수 있습니다. 고정하기는 async와 await를 활성화하기
위해 필요합니다.</p>
<p>두 번째로, <code>wake: fn()</code>은 <code>&amp;mut Context&lt;'_&gt;</code>으로 바뀌었습니다.
<code>SimpleFuture</code>에서는 future executor에게 진행할 준비가 된 것으로 보이는 future가
poll되어야 한다고 알려주기 위해 함수포인터(<code>fn()</code>)에 대한 호출을
사용하였습니다. 하지만, <code>fn()</code>은 단지 함수포인터일 뿐, <em>어떤</em> <code>Future</code>가
<code>wake</code>를 호출했는지에 대한 정보를 저장할 수 없습니다.</p>
<p>현실적인 시나리오에서, 웹 서버 같은 복잡한 어플리케이션에는 수 천개의 커넥션이
있을 것이고, 각 연결에 대한 wakeup은 모두 개별적으로 관리되어야 할 것입니다.
<code>Waker</code> 타입의 값에 대한 접근을 제공하는 <code>Context</code> 타입을 이용하여 이를 해결하는
데, 이 <code>Context</code>로 특정한 태스크를 깨울 수 있습니다. </p>
<h1><a class="header" href="#waker로-태스크-깨우기" id="waker로-태스크-깨우기"><code>Waker</code>로 태스크 깨우기</a></h1>
<p>future들이 첫 번째 <code>poll</code>에서는 완성되지 못하는 것이 일반적입니다. 완성되지
못했을 경우, 더 진행이 가능할 준비가 되면 future가 poll될 수 있게 확실히
조치해둘 필요가 있습니다. <code>Waker</code> 타입으로 이 조치를 취할 수 있습니다.</p>
<p>future가 poll될 때마다 한 &quot;태스크&quot;의 일부분으로서 poll됩니다. 태스크란 한
executor에게 제공된 최상위 future들입니다.</p>
<p><code>Waker</code>는 <code>wake()</code> 메소드를 제공하는데, 이 메소드는 연관된 태스크가 깨워져야
한다고 executor에게 알리는데 사용됩니다. <code>wake()</code>가 호출되었을 때, executor는
<code>Waker</code>와 연관된 태스크가 진행될 준비가 되었으며, 태스크의 future가 다시
poll되어야 한다는 것을 알 수 있습니다.</p>
<p><code>Waker</code>는 <code>clone()</code>도 구현하기 때문에, 필요한 곳에 복사되고 저장될 수 있습니다.</p>
<p><code>Waker</code>를 사용하여 간단한 타이머를 구현해 봅시다.</p>
<h2><a class="header" href="#응용-타이머-만들기" id="응용-타이머-만들기">응용: 타이머 만들기</a></h2>
<p>이 예제의 목적에 따라, 우리는 타이머가 만들어졌을 때 그냥 새 스레드를 하나
생성할 것이고, 필요한 만큼 sleep할 것입니다. 그리고 time window가 지나면,
타이머 future에 시그널을 보낼 것입니다.</p>
<p>시작하려면 다음처럼 import해야할 것들이 있습니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
<span class="boring">}
</span></code></pre></pre>
<p>먼저 future 타입 자체를 정의합시다. 우리의 future에게는 타이머가 경과되었는지,
그래서 future가 완성되어야 하는지 여부를 스레드와 통신할 방법이 필요합니다.
그래서 공유된 <code>Arc&lt;Mutex&lt;..&gt;&gt;</code> 값을 사용해서 스레드와 future 사이에 통신할
것입니다.</p>
<pre><code class="language-rust ignore">pub struct TimerFuture {
    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,
}

/// future와 대기중인 스레드 사이에 공유되어 상태를 나타내는 구조체
struct SharedState {
    /// 타이머가 경과되었는 지 여부
    completed: bool,

    /// `TimerFuture`가 실행될 태스크 용 waker.
    /// 스레드는 `completed = true`라고 설정한 후에 `TimerFuture`의 태스크에게
    /// &quot;일어나서, `completed = true`인지 확인하고, 진행하라&quot;고 전하는 데 이
    /// waker를 사용할 수 있다.
    waker: Option&lt;Waker&gt;,
}
</code></pre>
<p>자, 진짜로 <code>Future</code> 구현을 작성해 봅시다.</p>
<pre><code class="language-rust ignore">impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        // 타이머가 이미 완성되었는지 알기 위해 공유된 상태를 확인.
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // waker를 설정해서 타이머가 완성되었을 때 스레드가 현재의 태스크를
            // 깨울 수 있게 한다. 이렇게 함으로써 future는 다시 poll 될 수 있으며,
            // 또, `completed = true`가 맞는지 확인 할 수 있다.
            //
            // &quot;waker를 매번 반복적으로 클론하지 않고 한 번만 해도 되지
            // 않을까&quot; 생각할 수도 있다. 하지만, `TimerFuture`는 executor의 여러
            // 태스크로 이동할 수 있기 때문에, 클론을 한 번만 하면 잘못된
            // 태스크를 가리키는 정체된 waker가 만들어져 `TimerFuture`가 제대로
            // 못 깨워질 것이다.
            //
            // 주의: `Waker::will_wake` 함수를 이용하여 `TimerFuture`가
            // 제대로 못 깨워지는 문제를 체크할 수 있으나, 예제를 간단하게 
            // 하기 위해 생략하였다.
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}
</code></pre>
<p>꽤 간단하죠? 스레드가 <code>shared_state.completed = true</code>로 설정하였다면 <code>future</code>가
완성된 것입니다. 아니라면, 우리는 스레드가 태스크를 다시 깨울 수 있도록,
<code>Waker</code>를 현재의 태스크용으로 클론하여 <code>shared_state.waker</code>에 전달합니다.</p>
<p>중요한 점은, future가 poll될 때마다 <code>Waker</code>를 갱신해야 한다는 점입니다.
왜냐하면, 그 future가 다른 <code>Waker</code>와 함께 다른 태스크로 이동했을 수 있기
때문입니다.(TODO: 의역필요) 이런 상황은 future가 poll되고 나서 태스크 사이에서
여기저기 전달될 때 발생합니다.</p>
<p>마지막으로, 실제로 타이머를 만들고 스레드를 시작할 API가 필요합니다.</p>
<pre><code class="language-rust ignore">impl TimerFuture {
    /// 주어진 시간이 경과하면 완성되는 새로운 `TimerFuture`를 만든다.
    pub fn new(duration: Duration) -&gt; Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // 새로운 스레드 생성
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // 타이머가 완성되어서 future가 poll된 마지막 태스크를 (존재한다면)
            // 깨우는 시그널
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
</code></pre>
<p>짠! 이게 간단한 타이머 future를 만드는데 필요한 전부입니다. 이제 future가 실행될
executor만 있으면 되는데요...</p>
<h1><a class="header" href="#응용-executor-구현하기" id="응용-executor-구현하기">응용: executor 구현하기</a></h1>
<p>러스트 <code>Future</code>는 지연계산됩니다. 완성시키기 위해 실제로 구동하기 전까지
future는 아무것도 하지 않을 것입니다. future를 완성까지 구동하는 한 가지 방법은
<code>async</code> 함수 안에서 future를 <code>.await</code>하는 것입니다. 다만, 그렇게 하면 문제가
하나 생깁니다: 누가 최상위 <code>async</code> 함수로부터 반환된 future를 실행할 것인가라는
문제입니다. 그리고 그 해답은 <code>Future</code> executor입니다.</p>
<p><code>Future</code> executor는 최상위 <code>Future</code>의 집합을 받아 <code>Future</code>가 진행할 수 있을
때마다 <code>poll</code>을 호출해서 완성될 때까지 실행합니다. 일반적으로, executor는
시작하면서 future를 한 번 <code>poll</code>합니다. <code>Future</code>가 <code>wake()</code>를 호출하여 진행할
준비가 되었음을 알릴 때, future는 큐 뒤에 넣어지고, <code>poll</code>이 다시 호출됩니다.
이는 <code>Future</code>가 완성될 때까지 반복됩니다.</p>
<p>이 장에서 우리는 수많은 최상위 future를 완성될 때까지 동시에 실행할 수 있는
간단한 executor를 만들 것입니다.</p>
<p>이 예제에서 <code>Waker</code>를 쉽게 만들 수 있게 도와주는 <code>ArcWake</code> 트레잇 때문에
<code>futures</code> 크레잇 의존성이 필요합니다.</p>
<pre><code class="language-toml">[package]
name = &quot;xyz&quot;
version = &quot;0.1.0&quot;
authors = [&quot;XYZ Author&quot;]
edition = &quot;2018&quot;

[dependencies]
futures = &quot;0.3&quot;
</code></pre>
<p>다음은, <code>src/main.rs</code>의 맨 위에 아래와 같이 import합니다.</p>
<pre><code class="language-rust ignore">use {
    futures::{
        future::{BoxFuture, FutureExt},
        task::{waker_ref, ArcWake},
    },
    std::{
        future::Future,
        sync::mpsc::{sync_channel, Receiver, SyncSender},
        sync::{Arc, Mutex},
        task::{Context, Poll},
        time::Duration,
    },
    // 이전 장에서 작성한 타이머
    timer_future::TimerFuture,
};
</code></pre>
<p>실행할 태스크를 채널을 통해 보내면 우리의 executor가 작동할 겁니다. executor는
채널에서 이벤트를 당겨와서 실행합니다. 만약, 어떤 태스크가 조금 더 일 할 준비가
됐다면(즉, 깨워진다면), 그 태스크는 자기가 다시 poll될 수 있게 채널에 자기
스스로를 넣습니다.</p>
<p>이러한 설계 덕분에, executor는 그저 태스크 채널의 수신 단말만 있으면 됩니다.
유저에게는 송신 단말이 주어지므로, 새로은 future를 만들 수 있습니다. 태스크라는
것은 결국 스스로를 다시 스케쥴링할 수 있는 future일 뿐입니다. 따라서, 우리는
태스크들을 송신자(sender)와 짝지운 future의 형태로 저장할 것입니다. 송신자는
태스크가 자기자신을 큐에 넣는데 사용됩니다.</p>
<pre><code class="language-rust ignore">/// 채널에서 태스크를 받아서 실행하는 태스크 executor
struct Executor {
    ready_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
}

/// 새 future를 태스크 채널에 생성해 넣는 `Spawner`
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

/// `Executor`에게 poll될 수 있게 스스로를 재스케줄링하는 future
struct Task {
    /// 완성되기 위해서 큐에 넣어져야 하는, 진행중인 future
    ///
    /// 정확히 하자면, `Mutex`가 꼭 필요한 것은 아니다. 우리는 한 시점에
    /// (future들을 실행하는) 오직 하나의 스레드만 가지고 있기 때문이다. 하지만,
    /// 러스트는 우리의 `future`가 한 개의 스레드 안에서만 변경된다는 사실을 알
    /// 수 없기 때문에, 우리는 스레드 안전성을 위해 `Mutex`를 사용해야만 한다.
    /// 현업에서는 `Mutex` 대신 `UnsafeCell`을 사용할 수도 있다.
    future: Mutex&lt;Option&lt;BoxFuture&lt;'static, ()&gt;&gt;&gt;,

    /// 태스크가 자기자신을 태스크 큐의 마지막에 넣는데 사용되는 핸들
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

fn new_executor_and_spawner() -&gt; (Executor, Spawner) {
    // 채널(큐)이 일시점에 가질 수 있는 태스크의 최대 갯수.
    // 그냥 `sync_channel`을 만드는데 필요한 것이고, 실제 executor에 적용될 일은
    // 없을 것이다.
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}
</code></pre>
<p>새 future를 만들기 쉽게 메소드 한 개를 더 spawner에 추가합시다. 이 메소드는
future 타입을 받아서, box로 감싸고, 새 <code>Arc&lt;Task&gt;</code>로 만들 것입니다.
새로 만든 <code>Arch&lt;Task&gt;</code>는 excutor에게 enqueue될 것입니다.</p>
<pre><code class="language-rust ignore">impl Spawner {
    fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect(&quot;큐에 태스크가 너무 많습니다.&quot;);
    }
}
</code></pre>
<p>future를 poll하기 위해서는, <code>Waker</code>를 생성해야 합니다. <a href="02_execution/./03_wakeups.html">태스크 깨우기 section</a>에서
설명했듯이, <code>Waker</code>는 <code>wake</code>가 호출되면 태스크가 다시 poll될 수 있도록
스케쥴링합니다. <code>Waker</code>들은 executor에게 정확히 어떤 태스크가 준비되었는지
알려주기 때문에, executor는 진행할 준비가 된 future들만 poll한다는 점을
기억하십시오. 새로운 <code>Waker</code>를 만드는 가장 쉬운 방법은 <code>ArcWake</code> 트레잇을
구현하고, <code>waker_ref</code>나 <code>.into_waker()</code> 함수를 이용하여 <code>Arc&lt;impl ArcWake&gt;</code>를
<code>Waker</code>로 변경하는 것입니다. 우리의 태스크를 위한 <code>ArcWake</code>를 구현하여 <code>Waker</code>로
변경하고 깨워봅시다.</p>
<pre><code class="language-rust ignore">impl ArcWake for Task {
    fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
        // `wake`를 이 태스크를 다시 태스크 채널에 보내는 방식으로 구현한다. 그래서
        // executor가 이 태스크를 다시 poll할 것이다.
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect(&quot;큐에 태스크가 너무 많습니다.&quot;);
    }
}
</code></pre>
<p><code>Arc&lt;Task&gt;</code>로부터 만들어진 <code>Waker</code>의 <code>wake()</code>를 호출하면 <code>Arc</code>의 복사본이 태스크
채널로 송신될 것이다. 그러면 우리의 executor는 그 태스크를 집어 poll해야 한다.
구현해 봅시다.</p>
<pre><code class="language-rust ignore">impl Executor {
    fn run(&amp;self) {
        while let Ok(task) = self.ready_queue.recv() {
            // future를 취하고 나서, 아직 future가 완성되지 않았으면(아직 Some이면),
            // future를 완성하기 위해 poll한다.
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // task 자기자신으로부터 `LocalWaker`를 생성한다.
                let waker = waker_ref(&amp;task);
                let context = &amp;mut Context::from_waker(&amp;*waker);
                // `BoxFuture&lt;T&gt;`는 `Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send +
                // 'static&gt;&gt;`의 type alias이다.
                // `Pin::as_mut` 메소드를 호출하여 `BoxFuture&lt;T&gt;`로부터
                // `Pin&lt;&amp;mut dyn Future + Send + 'static&gt;`을 얻을 수 있다.
                if let Poll::Pending = future.as_mut().poll(context) {
                    // future의 처리가 끝나지 않았으므로, 그것의 task에 도로
                    // 넣어서 미래에 다시 실행될 수 있게 한다.
                    *future_slot = Some(future);
                }
            }
        }
    }
}
</code></pre>
<p>축하합니다! future executor를 완성하였습니다. 여러분이 만든 executor를
<code>asycn/.await</code> 코드나 우리가 아까 만든 <code>TimeFuture</code>같은 커스텀 future를
실행하는데도 사용할 수 있습니다.</p>
<pre><code class="language-rust edition2018 ignore">fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    // 타이머 전후로 문자열을 출력할 태스크를 생성한다.
    spawner.spawn(async {
        println!(&quot;howdy!&quot;);
        // 우리의 타이머 future가 2초 후에 완성될 때까지 기다린다.
        TimerFuture::new(Duration::new(2, 0)).await;
        println!(&quot;done!&quot;);
    });

    // 여러분의 executor가 spawner가 끝났음을 확인하고 더 이상 실행할 task를
    // 받지 않도록 spawner를 drop한다.
    drop(spawner);

    // excutor를 task 큐가 빌 때까지 실행한다. &quot;howdy!&quot; 출력, 일시중지,
    // &quot;done!&quot;출력 순으로 동작할 것이다.
    executor.run();
}
</code></pre>
<h1><a class="header" href="#executor와-시스템-입출력" id="executor와-시스템-입출력">Executor와 시스템 입출력</a></h1>
<p>우리는 이전 <a href="02_execution/./02_future.html"><code>Future</code> 트레잇</a> 장에서 소켓을 비동기적으로 읽는 아래의 future
예제에 대해 살펴보았습니다..</p>
<pre><code class="language-rust ignore">pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // 소켓에 데이터가 준비됨-- 버퍼에 읽어 들이고 버퍼를 반환
            Poll::Ready(self.socket.read_buf())
        } else {
            // 소켓에 아직 데이터가 준비되지 않음
            //
            // 데이터가 준비되면 `wake`가 호출될 수 있도록 조치함.
            // 데이터가 준비되면, `wake`가 호출되고, 이 `Future`의 사용자는
            // `poll`을 다시 호출하여 데이터를 읽을 수 있음을 알게 된다.
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p>이 future는 소켓에 준비된 데이터를 읽어들이지만, 준비된 데이터가 없다면
executor에게 &quot;소켓에 데이터가 준비되면 future의 태스크를 다시 깨워주세요&quot;라고
요청하면서 콘텍스트를 양보할 것입니다. 하지만, 이 예제에서는 <code>Socket</code> 타입이
어떻게 구현되는지 확실하지 않고, 특별히 <code>set_readable_callback</code> 함수가
작동하는지가 분명하지 않습니다. 어떻게 하면 소켓에 데이터가 준비되었을 때,
<code>wake()</code>가 호출될 수 있게 할까요? 끊임없이 <code>socket</code>이 준비되었는지 확인하여
맞으면 <code>wake()</code>를 호출하는 스레드를 하나 만드는 것도 선택지가 될 것입니다.
그러나 이 방법은 블록된 입출력 future 각각마다 별개의 스레드가 필요하기 때문에
매우 비효율적이어서 우리의 비동기 코드의 효율을 크게 저하시킬 것입니다.</p>
<p>사실 이 문제는 입출력과 연계된 시스템 블로킹 기본기능과 통합으로 해결합니다.
예를 들면 리눅스의 <code>epoll</code>, FreeBSD와 Mac OS의 <code>kqueue</code>, 윈도우즈의 IOCP,
퓨시아의 <code>port</code>같은 것들이 있습니다(그리고 이것들 모두는 크로스 플랫폼 려스트
크레잇인 <a href="https://github.com/tokio-rs/mio"><code>mio</code></a>를 이용하여 사용할 수 있습니다). 이러한 기본기능들은 모두 한
스레드가 여러개의 비동기 입출력 이벤트에 따라 블록하였다가 이벤트가 완성되면
반환할 수 있는 기능을 제공합니다. 이러한 API들은 실제로 보통 아래와 같은
형태입니다.</p>
<pre><code class="language-rust ignore">struct IoBlocker {
    /* ... */
}

struct Event {
    // 생성되어 전파되는 이벤트를 고유하게 식별하는 ID_
    id: usize,

    // 기다리고 있거나, 발생된 시그널 집합
    signals: Signals,
}

impl IoBlocker {
    /// 발생하면 블록할 비동기 입출력 이벤트의 새로운 컬렉션을 만든다.
    fn new() -&gt; Self { /* ... */ }

    /// 특정 입출력 이벤트에 interest를 표시한다.
    fn add_io_event_interest(
        &amp;self,

        /// 이벤트가 발생할 오브젝트
        io_object: &amp;IoObject,

        /// 이벤트가 발동되어야 하는 `io_object`에 발생할 시그널들의 집합으로, 
        /// 이 interest로부터 비롯된 이벤트에 부여될 ID와 짝지워진다.
        event: Event,
    ) { /* ... */ }

    /// 이벤트 중에 하나가 발생할 때까지 블록한다.
    fn block(&amp;self) -&gt; Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &amp;socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &amp;socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// 소켓에 데이터가 준비되면 &quot;Socket 1 is now READABLE&quot; 같은 걸 출력한다.
println!(&quot;Socket {:?} is now {:?}&quot;, event.id, event.signals);
</code></pre>
<p>future의 executor들은 아래의 기본기능들을 비동기 입출력 객체를 제공하기 위해
사용할 수 있습니다. 예를 들어, 소켓은 특별한 입출력 이벤트가 발생하였을 때, 콜백이
실행되도록 설정할 수 있습니다. 위의 <code>SocketRead</code> 예제의 경우에
<code>Socket::set_readable_callback</code> 함수는 아래와 같은 의사코드와 비슷한 형태일
것입니다.</p>
<pre><code class="language-rust ignore">impl Socket {
    fn set_readable_callback(&amp;self, waker: Waker) {
        // `local_executor`는 로컬 executor에 대한 레퍼런스이다.
        // `local_executor`는 소켓 생성시에 제공될 수도 있었겠지만, 실제로는 
        // 편의상 많은 executor 구현에서 스레드의 로컬 스토리지에
        // 두고 사용한다.
        let local_executor = self.local_executor;

        // 이 입출력 객체의 고유 ID
        let id = self.id;

        // executor의 맵에 로컬 waker를 저장하여 입출력 이벤트가
        // 도착하면 로컬 wake가 호출될 수 있다.
        local_executor.event_map.insert(id, waker);
        local_executor.add_io_event_interest(
            &amp;self.socket_file_descriptor,
            Event { id, signals: READABLE },
        );
    }
}
</code></pre>
<p>이로써 우리는 어떤 입출력 이벤트라도 받아서 딱맞는 <code>Waker</code>에게 보내줄 수 있는
executor 스레드를 만들었습니다. 그리고 <code>Waker</code>는 이벤트에 대응하는 태스크를 깨울
것입니다. 또, executor는 입출력 이벤트를 더 확인하기 전에 보다 많은 태스크들을
완성될까지 구동할 수 있을 것입니다(그리고 사이클은 반복됩니다...).</p>
<h1><a class="header" href="#asyncawait" id="asyncawait"><code>async</code>/<code>.await</code></a></h1>
<p>첫 장에서 우리는 <code>async</code>/<code>.await</code>을 짧게 다뤘습니다. 이제 <code>async</code> 코드가
어떻게 동작하고, 어떻게 전형적인 러스트 프로그램과 다른지 더 자세히 들여다봅시다.</p>
<p><code>async</code>/<code>.await</code>은 하나의 작업을 마칠 때 까지 기다리는 동안 다른 코드가 실행되는 것을 
막거나 허용하는 대신 현재 스레드의 제어를 내놓는 러스트 문법의 특별한 도구입니다.</p>
<p><code>async</code>를 다루는 주 방법 두 가지, <code>async fn</code>과 <code>async</code> 블록이 있습니다. 각각 <code>Future</code> 
트레잇을 구현한 값을 반환합니다.</p>
<pre><code class="language-rust edition2018 ignore">
// `foo()`는 `Future&lt;Output = u8&gt;`을 구현한 타입을 반환합니다.
// `foo().await`은 `u8` 타입의 값을 나타낼 것입니다.
async fn foo() -&gt; u8 { 5 }

fn bar() -&gt; impl Future&lt;Output = u8&gt; {
    // 이 `async` 블록은`Future&lt;Output = u8&gt;`을 구현한
    // 타입을 반환합니다.
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
</code></pre>
<p>첫 장에서 봤듯이, <code>async</code> 안쪽과 그 밖의 future 구현체는 게으릅니다. 즉 실행될 때까지 아무 
일도 안 합니다. <code>Future</code>를 실행하기 위해서는 <code>.await</code>을 써야 합니다. <code>Future</code> 상에서 
<code>.await</code>이 나오면 그 코드는 마칠 때까지 실행하려 할 것입니다. <code>Future</code>는 자신이 중지되면 
현재 스레드의 제어를 넘겨줍니다. 더 많은 흐름이 나올 시, <code>Future</code>는 <code>.await</code>을 풀고 실행자에게 
선택돼 실행을 재개할 것입니다.</p>
<h2><a class="header" href="#async한-수명" id="async한-수명"><code>async</code>한 수명</a></h2>
<p>참조나 기타 <code>'static</code>하지 않은 인자를 취하는 <code>async fn</code>은 다른 전형적인 함수들과
달리 인자의 라이프타임에 바운드 된 <code>Future</code>를 반환합니다.</p>
<pre><code class="language-rust edition2018 ignore">// 이 함수는
async fn foo(x: &amp;u8) -&gt; u8 { *x }

// 이 함수와 같습니다.
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}
</code></pre>
<p>즉 <code>'static</code>하지 않은 인자가 여전히 유효하는 한 <code>async fn</code>에서 나온 future는 <code>.await</code>해야 
합니다. 보통 <code>foo(&amp;x).await</code>와 같이 함수를 호출하고 바로 future를 <code>.await</code>할 때는 문제가 
없습니다. 허나 future를 또다른 작업이나 스레드로 저장하거나 보내면 문제가 생길 수 있습니다.</p>
<p>참조를 인자로 가진 <code>async fn</code>을 <code>'static</code>한 future로 바꾸는 방법 한 가지는 <code>async fn</code> 호출과 
인자값을 하나의 <code>async</code> 블록으로 묶는 것입니다.</p>
<pre><code class="language-rust edition2018 ignore">fn bad() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    borrow_x(&amp;x) // ERROR: `x`가 더 이상 쓸 수 없습니다.
}

fn good() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        borrow_x(&amp;x).await
    }
}
</code></pre>
<p>우리는 인자를 <code>async</code> 블록으로 옮김으로써 <code>good</code> 함수에서 나오는 <code>Future</code>의 것과 맞춰 인자의 
수명을 늘릴 수 있습니다.</p>
<h2><a class="header" href="#async-move" id="async-move"><code>async move</code></a></h2>
<p><code>async</code> 블록과 클로저는 보통 클로저처럼 <code>move</code> 키워드를 허용합니다. <code>async move</code> 블록은
자신이 참조하는 변수의 소유권을 현재 구역보다 더 오래 살리면서 다른 코드가 공유할 수 없도록 합니다.</p>
<pre><code class="language-rust edition2018 ignore">/// `async` 블록:
///
/// 여러 `async` 블록은 같은 지역 변수에 접근할 수 있고
/// 변수의 구역 안에서 실행될 수 있습니다.
async fn blocks() {
    let my_string = &quot;foo&quot;.to_string();

    let future_one = async {
        // ...
        println!(&quot;{}&quot;, my_string);
    };

    let future_two = async {
        // ...
        println!(&quot;{}&quot;, my_string);
    };

    // 두 future를 완전히 실행해 &quot;foo&quot;를 두 번 출력합니다:
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` 블록:
///
/// `async move` 블록으로부터 나온 `Future`가 캡처를 옮긴 이후로는 `async move` 
/// 블록 하나만 같은 캡처된 변수에 접근할 수 있습니다. 허나 이러면 `Future`를 원래 
/// 그 변수의 구역에서보다 오래 살게 합니다.
fn move_block() -&gt; impl Future&lt;Output = ()&gt; {
    let my_string = &quot;foo&quot;.to_string();
    async move {
        // ...
        println!(&quot;{}&quot;, my_string);
    }
}
</code></pre>
<h2><a class="header" href="#멀티스레드-실행자-상에서-await하기" id="멀티스레드-실행자-상에서-await하기">멀티스레드 실행자 상에서 <code>.await</code>하기</a></h2>
<p><code>Future</code>는 멀티스레드 상에서 <code>Future</code> 실행자를 사용할 때, <code>async</code> 안쪽에 쓰인 어떤 
변수라도 스레드 사이를 넘나들 수 있어야 하기 위해 어떤 <code>.await</code>이라도 잠재적으로 새로운 
스레드로 갈아탈 수 있듯이 스레드 사이를 건널 수도 있습니다.</p>
<p>그 말인 즉슨 <code>Sync</code> 트레잇을 구현하지 않은 타입에 대한 참조를 비롯해 <code>Send</code> 트레잇을 
구현하지 않은 <code>Rc</code>, <code>&amp;RefCell</code> 등 어떠한 타입도 안전하지 않습니다.</p>
<p>(경고: <code>.await</code>을 호출하는 동안 스코프 안에 없는 타입들은 사용할 수 있습니다.)</p>
<p>요컨데 <code>.await</code>을 넘어서 future가 인식할 수 없는 전형적인 락을 다루는 것은 좋은 생각이 
아닙니다. 하나가 락을 차지하고, <code>.await</code>하면서 실행자에게 내놓는다면 또다른 작업이 락을 차지하려 
해 데드락이 발생하기 때문입니다. 이런 문제를 피하기 위해 <code>std::sync</code> 대신 <code>futures::lock</code>에 
있는 <code>Mutex</code>를 사용하시기 바랍니다.</p>
<h1><a class="header" href="#고정하기pinning" id="고정하기pinning">고정하기(Pinning)</a></h1>
<p>future를 poll하기 위해서는, future가 <code>Pin&lt;T&gt;</code>라는 특별한 타입으로 고정되어
있어야 합니다. 이전 <a href="04_pinning/../02_execution/01_chapter.html">&quot;<code>Future</code>와 태스크 실행하기&quot;</a> 장의 <a href="04_pinning/../02_execution/02_future.html"><code>Future</code> 트레잇</a>을
읽었다면, <code>Future::poll</code> 메소드의 정의에서 <code>self Pin&lt;&amp;mut Self&gt;</code>에 쓰였던
<code>Pin</code>을 보았을 것입니다. 그렇다면 <code>Pin</code>은 무슨 의미이고, 왜 필요할까요?</p>
<h2><a class="header" href="#왜-고정해야-하나요" id="왜-고정해야-하나요">왜 고정해야 하나요</a></h2>
<p><code>Pin</code>은 <code>Unpin</code> 마커와 쌍으로 작동합니다. 고정하기는 <code>!Unpin</code>을 구현하는 객체가
절대 움직이지 않음을 보장하여 줍니다. 이게 왜 필요한지 이해하려면, <code>async</code> /
<code>.await</code>가 작동하는 방식을 떠올려 보세요. 아래 코드를 살펴봅시다.</p>
<pre><code class="language-rust edition2018 ignore">let fut_one = /* ... */;
let fut_two = /* ... */;
async move {
    fut_one.await;
    fut_two.await;
}
</code></pre>
<p>보이지는 않지만, 위 코드는 <code>Future</code>를 구현하는 익명 타입을 만들어, 아래와 같은
<code>poll</code> 메소드를 제공합니다.</p>
<pre><code class="language-rust ignore">// 위 `async { ... }` 블록이 생성한 `Future` 타입
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// 위 `async`블록이 될 수 있는 상태의 종류
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        loop {
            match self.state {
                State::AwaitingFutOne =&gt; match self.fut_one.poll(..) {
                    Poll::Ready(()) =&gt; self.state = State::AwaitingFutTwo,
                    Poll::Pending =&gt; return Poll::Pending,
                }
                State::AwaitingFutTwo =&gt; match self.fut_two.poll(..) {
                    Poll::Ready(()) =&gt; self.state = State::Done,
                    Poll::Pending =&gt; return Poll::Pending,
                }
                State::Done =&gt; return Poll::Ready(()),
            }
        }
    }
}
</code></pre>
<p><code>poll</code>이 처음 호출되면 <code>poll</code>은 <code>fut_one</code>을 poll할 것입니다. 만약 <code>fut_one</code>이
완성될 수 없다면, <code>AsyncFuture::poll</code>은 <code>Poll::Pending</code>을 반환할 것입니다.
다시 future의 <code>poll</code>을 호출하면 이전 future가 중단된 지점부터 다시 시작할 것입니다.
이 과정은 future가 성공적으로 완성될 때까지 반복될 것입니다.</p>
<p>하지만, <code>async</code> 블록이 참조를 사용한다면 어떻게 될까요?</p>
<p>예를 들어:</p>
<pre><code class="language-rust edition2018 ignore">async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&amp;mut x);
    read_into_buf_fut.await;
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p>위 코드는 어떤 구조체로 변환될까요?</p>
<pre><code class="language-rust ignore">struct ReadIntoBuf&lt;'a&gt; {
    buf: &amp;'a mut [u8], // 아래 `x`를 가리킴
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf&lt;'what_lifetime?&gt;,
}
</code></pre>
<p>여기 <code>ReadIntoBuf</code> future는 우리 구조체의 다른 필드인 <code>x</code>를 가리키는 참조를
가지고 있습니다. 따라서, <code>AsyncFuture</code>가 옮겨진다면, <code>x</code>의 위치도 같이 움직이면서 
<code>read_into_buf_fut.buf</code>에 저장된 포인터도 무효화 될 것입니다.</p>
<p>future를 특정된 메모리 위치에 고정함으로서 이 문제를 방지하고, <code>async</code> 블록 안에
있는 값에 대한 참조를 안전하게 만들 수 있습니다.</p>
<h2><a class="header" href="#고정하기에-대한-상세설명" id="고정하기에-대한-상세설명">고정하기에 대한 상세설명</a></h2>
<p>조금 더 간단한 예제로 고정하기를 이해해 봅시다. 위의 문제의 핵심은 '러스트에서
자기참조 타입의 참조를 어떻게 다루는가'입니다.</p>
<p>지금부터 우리의 예제는 다음과 같이 바뀔 겁니다.</p>
<pre><code class="language-rust ignore">use std::pin::Pin;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *const String = &amp;self.a;
        self.b = self_ref;
    }

    fn a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }

    fn b(&amp;self) -&gt; &amp;String {
        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
        unsafe {&amp;*(self.b)}
    }
}
</code></pre>
<p><code>Test</code>는 <code>a</code>와 <code>b</code> 필드의 값에 대한 참조를 얻는 메소드를 제공합니다. <code>b</code>는 <code>a</code>에
대한 참조이기 때문에 <code>b</code>에 포인터를 사용합니다. 왜냐하면, 러스트의 빌림규칙에
따라 이 라이프타임을 정의할 수 없기 때문입니다. 이 구조체가 바로 자기-참조
구조체라고 불리는 것입니다.</p>
<p>아래 예제를 실행하면 알 수 있듯이, 어느 데이타도 여기저기 움직이지 않는다면 위
예제는 잘 작동할 겁니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
<span class="boring">use std::pin::Pin;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // 자기-참조를 실제로 설정할 `init` 메소드
</span><span class="boring">    fn init(&amp;mut self) {
</span><span class="boring">        let self_ref: *const String = &amp;self.a;
</span><span class="boring">        self.b = self_ref;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b(&amp;self) -&gt; &amp;String {
</span><span class="boring">        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
</span><span class="boring">        unsafe {&amp;*(self.b)}
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>예상한 대로 출력됩니다.</p>
<pre><code class="language-rust ignore">a: test1, b: test1
a: test2, b: test2
</code></pre>
<p>그럼 <code>test1</code>과 <code>test2</code>를 스왑하여 데이터를 움직여보고, 무슨 일이 생기는 지 봅시다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
<span class="boring">use std::pin::Pin;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn init(&amp;mut self) {
</span><span class="boring">        let self_ref: *const String = &amp;self.a;
</span><span class="boring">        self.b = self_ref;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b(&amp;self) -&gt; &amp;String {
</span><span class="boring">        unsafe {&amp;*(self.b)}
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>단순하게 생각하면, 아래처럼 두 번 다 <code>test1</code>의 디버그 내용이 출력될 것이라
생각하기 십상입니다:</p>
<pre><code class="language-rust ignore">a: test1, b: test1
a: test1, b: test1
</code></pre>
<p>하지만 실제 출력은 다음과 같습니다:</p>
<pre><code class="language-rust ignore">a: test1, b: test1
a: test1, b: test2
</code></pre>
<p>스왑 이후에도, <code>test2.b</code>에 대한 포인터는 현재 <code>test1</code> 내부에 있는 옛
위치를 여전히 가리킵니다. 이 구조체는 더 이상 자기-참조적이지
않으며, 다른 객체 안에 있는 필드를 가리키는 포인터를 가지게 됩니다. 즉,
<code>test2</code>의 라이프타임에 매여있는 <code>test2.b</code>의 라이프타임을 더이상 신뢰할 수 없다는
뜻입니다.</p>
<p>만약 아직도 이해가 되지 않는다면, 아래 코드가 확실히 이해시켜 줄 것입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    test1.a = &quot;I've totally changed now!&quot;.to_string();
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
<span class="boring">use std::pin::Pin;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn init(&amp;mut self) {
</span><span class="boring">        let self_ref: *const String = &amp;self.a;
</span><span class="boring">        self.b = self_ref;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b(&amp;self) -&gt; &amp;String {
</span><span class="boring">        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
</span><span class="boring">        unsafe {&amp;*(self.b)}
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>아래 그림은 이 내용들을 도식화합니다.</p>
<p><strong>Fig 1: 스왑 전 후</strong>
<img src="04_pinning/../assets/swap_problem.jpg" alt="swap_problem" /></p>
<p>다른 특별한 방법도 있겠지만, 위와 같이 그림으로 정의되지 않은 동작과 실패를 표현하면
이해하기 쉽습니다.</p>
<h2><a class="header" href="#실전에서-고정하기" id="실전에서-고정하기">실전에서 고정하기</a></h2>
<p>고정하기와 <code>Pin</code> 타입으로 이 문제를 해결하는지 알아봅시다.</p>
<p><code>Pin</code> 타입은 포인터를 감싸서 포인터 뒤에 있는 값이 움직이지 않음을 보장해줍니다.
예를 들어, <code>Pin&lt;&amp;mut T&gt;</code>, <code>Pin&lt;&amp;T&gt;</code>, <code>Pin&lt;Box&lt;T&gt;&gt;</code>들은 모두 <code>T: !Unpin</code>이라면
<code>T</code>가 움직이지 않음을 보장합니다.</p>
<p>대부분의 타입들에게는 이동되는 문제점이 없습니다. 이러한 타입들은 <code>Unpin</code>이라는
트레잇을 구현합니다. <code>Unpin</code> 타입에 대한 포인터들은 자유롭게 <code>Pin</code> 안에 넣거나
꺼낼 수 있습니다. 예를 들어, <code>u8</code>은 <code>Unpin</code>이어서 <code>Pin&lt;&amp;mut u8&gt;</code>은 그냥 평범한
<code>&amp;mut u8</code>처럼 작동합니다.</p>
<p>하지만, 고정된 다음에는 움직일 수 없는 타입들은 <code>!Unpin</code>이라는 마커를 가지고
있습니다. async/await에 의해 만들어진 future들이 그 예시입니다.</p>
<h3><a class="header" href="#스택에-고정하기" id="스택에-고정하기">스택에 고정하기</a></h3>
<p>다시 예제로 돌아가서, <code>Pin</code>을 이용하면 문제를 해결할 수 있습니다. 고정된
포인터를 사용하면 우리의 예제가 어떻게 바뀌는지 살펴봅시다.</p>
<pre><code class="language-rust ignore">use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // 이렇게 하면 이 타입을 `!Unpin`으로 바꿈 
        }
    }
    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
        let self_ptr: *const String = &amp;self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
        unsafe { &amp;*(self.b) }
    }
}
</code></pre>
<p>우리의 타입이 <code>!Unpin</code>을 구현한다면 객체를 스택에 고정하는 것은 항상 <code>unsafe</code>할
것입니다. 여러분은 스택에 고정할 때 <code>unsafe</code> 코드를 직접 사용하지 않으려면
<a href="https://docs.rs/pin-utils/"><code>pin_utils</code></a> 같은 크레잇을 사용할 수 있습니다.</p>
<p>아래처럼, 객체 <code>test1</code>과 <code>test2</code>를 스택에 고정합시다.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    // test1은 초기화되기 전에 움직여도 안전합니다.
    let mut test1 = Test::new(&quot;test1&quot;);
    // `test1`이 다시 액세스되는 것을 막기 위해 어떻게 `test1`을 쉐도우하는지 확인해 두세요
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new(&quot;test2&quot;);
    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut test2) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
<span class="boring">use std::pin::Pin;
</span><span class="boring">use std::marker::PhantomPinned;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">    _marker: PhantomPinned,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">            // 우리의 타입을 `!Unpin`으로 만듭니다.
</span><span class="boring">            _marker: PhantomPinned,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
</span><span class="boring">        let self_ptr: *const String = &amp;self.a;
</span><span class="boring">        let this = unsafe { self.get_unchecked_mut() };
</span><span class="boring">        this.b = self_ptr;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
</span><span class="boring">        &amp;self.get_ref().a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
</span><span class="boring">        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
</span><span class="boring">        unsafe { &amp;*(self.b) }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>자, 만약 지금 우리가 데이터를 움직이려고 하면, 컴파일 에러가 발생합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">pub fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new(&quot;test2&quot;);
    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut test2) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
<span class="boring">use std::pin::Pin;
</span><span class="boring">use std::marker::PhantomPinned;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">    _marker: PhantomPinned,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">            _marker: PhantomPinned, // 우리의 타입을 `!Unpin`으로 만듭니다.
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
</span><span class="boring">        let self_ptr: *const String = &amp;self.a;
</span><span class="boring">        let this = unsafe { self.get_unchecked_mut() };
</span><span class="boring">        this.b = self_ptr;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
</span><span class="boring">        &amp;self.get_ref().a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
</span><span class="boring">        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
</span><span class="boring">        unsafe { &amp;*(self.b) }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>타입 시스템은 우리가 데이터를 움직이지 못하게 막아줍니다.</p>
<blockquote>
<p>스택에 고정하기는 <code>unsafe</code>를 사용하므로 항상 여러분이 보증해야 한다는 점을
명심하세요. <code>'a</code> 라이프타임 안에서는 <code>&amp;'a mut T</code>가 _가리키는 값_이 고정된지만,
<code>'a</code>가 끝난 다음에도 <code>&amp;'a mut T</code>가 가리키는 데이터가 안 움직였는지 알 수는
없습니다. 만약 <code>&amp;'a mut T</code>가 가리키는 데이터가 <code>'a</code>가 끝난 다음에 움직인다면
Pin 규칙을 어기게 될 것입니다.</p>
</blockquote>
<blockquote>
<p>원 변수를 쉐도우하는 것을 깜빡하기 쉽습니다. 왜냐하면, (Pin 규칙을 어기는)
아래 코드처럼, <code>Pin</code>을 드랍하고 나서, <code>&amp;'a mut T</code> 다음에 데이타를 움직일
가능성이 있기 때문입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let mut test1 = Test::new(&quot;test1&quot;);
   let mut test1_pin = unsafe { Pin::new_unchecked(&amp;mut test1) };
   Test::init(test1_pin.as_mut());
   drop(test1_pin);
   println!(r#&quot;test1.b points to &quot;test1&quot;: {:?}...&quot;#, test1.b);
   let mut test2 = Test::new(&quot;test2&quot;);
   mem::swap(&amp;mut test1, &amp;mut test2);
   println!(&quot;... and now it points nowhere: {:?}&quot;, test1.b);
}
<span class="boring">use std::pin::Pin;
</span><span class="boring">use std::marker::PhantomPinned;
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">    _marker: PhantomPinned,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">            // This makes our type `!Unpin`
</span><span class="boring">            _marker: PhantomPinned,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
</span><span class="boring">        let self_ptr: *const String = &amp;self.a;
</span><span class="boring">        let this = unsafe { self.get_unchecked_mut() };
</span><span class="boring">        this.b = self_ptr;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
</span><span class="boring">        &amp;self.get_ref().a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
</span><span class="boring">        assert!(!self.b.is_null(), &quot;Test::b called without Test::init being called first&quot;);
</span><span class="boring">        unsafe { &amp;*(self.b) }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
</blockquote>
<h3><a class="header" href="#힙-역역에-고정하기" id="힙-역역에-고정하기">힙 역역에 고정하기</a></h3>
<p><code>!Unpin</code>타입을 힙에 고정하면 우리 데이타에 안정적인 주소를 부여하게 됩니다.
그래서 우리가 가리키는 데이터는 고정되고 나면 움직일 수 없습니다. 스택에
고정하기와 대조적으로, 데이터가 객체의 수명주기동안 고정됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
   a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &amp;boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    let mut test2 = Test::new(&quot;test2&quot;);

    println!(&quot;a: {}, b: {}&quot;,test1.as_ref().a(), test1.as_ref().b());
    println!(&quot;a: {}, b: {}&quot;,test2.as_ref().a(), test2.as_ref().b());
}
</code></pre></pre>
<p>몇몇 함수들은 future가 <code>Unpin</code> 타입일 것을 요구합니다. <code>Unpin</code>이 아닌 <code>Future</code>나
<code>Stream</code>을 <code>Unpin</code> 타입을 요구하는 함수와 함께 사용하기 위해서는, 먼저
(<code>Pin&lt;Box&lt;T&gt;&gt;</code>을 만든다면) <code>Box::pin</code>이나 (<code>Pin&lt;&amp;mut T&gt;</code>를 만든다면)
<code>pin_utils::pin_mut!</code> 매크로를 사용하여 값을 고정해야 합니다. <code>Pin&lt;Box&lt;Fut&gt;&gt;</code>와
<code>Pin&lt;&amp;mut Fut&gt;</code> 둘 다 future처럼 사용될 수 있으며, 둘 다 <code>Unpin</code>을 구현합니다.</p>
<p>예를 들어:</p>
<pre><code class="language-rust edition2018 ignore">use pin_utils::pin_mut; // `pin_utils`는 crates.io에 있는 가벼운 crate입니다.

// `Unpin`을 구현하는 `Future`를 취하는 함수
fn execute_unpin_future(x: impl Future&lt;Output = ()&gt; + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // 오류: `fut`은 `Unpin` 트레잇을 구현하지 않음

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
</code></pre>
<h2><a class="header" href="#정리" id="정리">정리</a></h2>
<ol>
<li>
<p><code>T: Unpin</code>(기본값)이라면 <code>Pin&lt;'a, T&gt;</code>는 <code>&amp;'a mut T</code>와 전적으로 동일합니다.
다르게 표현하자면, <code>Unpin</code>은 &quot;이 타입은 고정되었을지라도 움직여도 됨&quot;을
의미합니다. 따라서 <code>Pin</code>은 해당 타입에 대해 효과가 없습니다.</p>
</li>
<li>
<p><code>T: !Unpin</code>일 때, 고정된 T에 대하여 <code>&amp;mut T</code>를 얻으려면 unsafe가 필요합니다.</p>
</li>
<li>
<p>대부분의 표준 라이브러리 타입들은 <code>Unpin</code>을 구현합니다. 여러분이 러스트에서
사용할 대부분의 &quot;평범한&quot; 타입들도 마찬가지입니다. async/await에 의해 생성된
<code>Future</code>는 이 규칙에 예외입니다.</p>
</li>
<li>
<p>nightly에서는 feature flag를 설정하면 어떤 타입에 <code>!Unpin</code> 바운드를 추가할 수
있습니다. stable에서는 타입에 <code>std::marker::PhantomPinned</code>를 추가하면 됩니다.</p>
</li>
<li>
<p>데이타를 스택이나 힙에 고정할 수 있습니다.</p>
</li>
<li>
<p><code>!Unpin</code> 객체를 스택에 고정하려면 <code>unsafe</code>가 필요합니다.</p>
</li>
<li>
<p><code>!Unpin</code> 객체를 힙에 고정할 때는 <code>unsafe</code>가 필요 없습니다. <code>Box::pin</code>을
사용하면 간단하게 할 수 있습니다.</p>
</li>
<li>
<p><code>T: !Unpin</code>인 고정된 데이터에 대해서는, 여러분이 그 데이터의 메모리가
_고정되어 drop이 호출되기 전_까지 무효화되거나 용도변경되지 않음(불변성)을
유지할 책임이 있습니다. 이는 _고정 규칙_에서 중요한 부분입니다.</p>
</li>
</ol>
<h1><a class="header" href="#stream-트레잇" id="stream-트레잇"><code>Stream</code> 트레잇</a></h1>
<p><code>Stream</code> 트레잇은 <code>Future</code>와 비슷하지만 작업을 끝내기 전 여러 값을 산출할 수
있다는 점에서 다릅니다. <code>Stream</code>은 표준 라이브러리의 <code>Iterator</code> 트레잇과
비슷하다고 보면 됩니다.</p>
<pre><code class="language-rust ignore">trait Stream {
    /// 스트림이 양보하는 값의 타입
    type Item;

    /// 스트림에 있는 다음 아이템을 해결하려 한다.
    /// 아직 준비가 안 됐으면 `Poll::Pending`, 준비가 되었으면 `Poll::Ready(Some(x))`
    /// , 끝났으면 `Poll::Ready(None)`을 반환한다.
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
</code></pre>
<p><code>Stream</code>의 한 가지 예시로 <code>futures</code> 크레이트에 있고 채널 타입에 쓰이는
<code>Receiver</code>가 있습니다. <code>Sender</code> 단에서 값을 보낼 때마다 <code>Some(val)</code>을 내놓고,
<code>Sender</code>가 드랍되고 모든 대기 메시지를 다 받았을 때에는 <code>None</code>을 반환합니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn send_recv() {
    const BUFFER_SIZE: usize = 10;
    let (mut tx, mut rx) = mpsc::channel::&lt;i32&gt;(BUFFER_SIZE);

    tx.send(1).await.unwrap();
    tx.send(2).await.unwrap();
    drop(tx);

    // `StreamExt::next` 는 `Iterator::next`와 같지만, 
    // `Future&lt;Output = Option&lt;T&gt;&gt;`을 구현한 타입을 반환한다.
    assert_eq!(Some(1), rx.next().await);
    assert_eq!(Some(2), rx.next().await);
    assert_eq!(None, rx.next().await);
}
</code></pre>
<h1><a class="header" href="#반복과-동시성" id="반복과-동시성">반복과 동시성</a></h1>
<p>동기적 <code>Iterator</code>와 같이 <code>Stream</code>에서 값을 반복하고 처리하는 여러 가지 방법이 있습니다.
<code>map</code>, <code>filter</code>, <code>fold</code>와 같은 콤비네이터 방식과 <code>try_map</code>, <code>try_filter</code>, <code>try_fold</code>와 
같이 오류가 생기면 바로 종료하는 방식의 메소드가 있습니다.</p>
<p>슬프게도 <code>for</code> 반복문은 <code>Stream</code>과 같이 사용할 수 없지만, 명령형 코드를 위해 
<code>while let</code>과 <code>next</code>/<code>try_next</code> 함수를 쓸 수 있습니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn sum_with_next(mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = i32&gt;&gt;) -&gt; i32 {
    use futures::stream::StreamExt; // `next`를 쓰기 위함
    let mut sum = 0;
    while let Some(item) = stream.next().await {
        sum += item;
    }
    sum
}

async fn sum_with_try_next(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;i32, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;i32, io::Error&gt; {
    use futures::stream::TryStreamExt; // `try_next`를 쓰기 위함
    let mut sum = 0;
    while let Some(item) = stream.try_next().await? {
        sum += item;
    }
    Ok(sum)
}
</code></pre>
<p>하지만 우리가 단지 한 시점에 요소 한 개만 처리하고 있다면 잠재적으로 동시성의
기회를 내다버린 것과 다를 바 없습니다. 이 점이 바로 처음부터 비동기 코드를 써야 하는
이유입니다. 한 스트림 안에서 여러 아이템을 동시에 다루기 위해
<code>for_each_concurrent</code>와 <code>try_for_each_concurrent</code> 메소드를 사용하시기 바랍니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn jump_around(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;u8, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;(), io::Error&gt; {
    use futures::stream::TryStreamExt; // `try_for_each_concurrent`를 쓰기 위함
    const MAX_CONCURRENT_JUMPERS: usize = 100;

    stream.try_for_each_concurrent(MAX_CONCURRENT_JUMPERS, |num| async move {
        jump_n_times(num).await?;
        report_n_jumps(num).await?;
        Ok(())
    }).await?;

    Ok(())
}
</code></pre>
<h1><a class="header" href="#여러개의-future를-동시에-실행하기" id="여러개의-future를-동시에-실행하기">여러개의 future를 동시에 실행하기</a></h1>
<p>지금까지, 대부분의 future를 현재의 태스크를 <code>Future</code>가 완성될 때까지 블록하는
<code>.await</code>로 실행시켰습니다. 그러나, 진짜 비동기 어플리케이션은 종종 몇개의 다른
작업을 동시에 실행할 필요가 있습니다.</p>
<p>이 장에서는 여러개의 비동기 작업들을 동시에 싱행하는 몇가지 방법들을 배울 것입니다.</p>
<ul>
<li><code>join!</code> : future들이 모두 완성될 때까지 기다림</li>
<li><code>select!</code> : 여러 future 중에 한개가 완료될 때까지 기다림</li>
<li>스포닝 : 한 개의 future를 완성될 때까지 주변에서 실행하는 최상위 태스크를 만듦</li>
<li><code>FuturesUnordered</code> : future들의 그룹. 각각의 하위future의 결과를 산출함</li>
</ul>
<h1><a class="header" href="#join" id="join"><code>join!</code></a></h1>
<p><code>futures::join</code> 매크로는 여러개의 다른 future를 동시에 실행하여 모두 완성될
때까지 기다리게 해줍니다.</p>
<h1><a class="header" href="#join-1" id="join-1"><code>join!</code></a></h1>
<p>여러개의 비동기 작업을 진행할 때, 단순하게 <code>.await</code>를 순차적으로 사용하는 식으로
만들기 쉽습니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn get_book_and_music() -&gt; (Book, Music) {
    let book = get_book().await;
    let music = get_music().await;
    (book, music)
}
</code></pre>
<p>그런데, 이렇게 하면 필요한 만큼 성능을 낼 수 없습니다. 왜냐하면, <code>get_book</code>이
완성될 때까지 <code>get_music</code>을 시작하려 하지 않을 것이기 때문입니다. 몇몇 다른
언어에서는, future가 완성될 때까지 주변적으로(ambiently) 실행되는 방식을
사용하기도 합니다. 이 방식에서는 처음부터 각 <code>async fn</code>을 호출하여 future들을
시작하고, 둘 모두를 기다림으로써, 두 작업이 동시에 실행될 수 있습니다.</p>
<pre><code class="language-rust edition2018 ignore">// WRONG -- 따라하지 마시오
async fn get_book_and_music() -&gt; (Book, Music) {
    let book_future = get_book();
    let music_future = get_music();
    (book_future.await, music_future.await)
}
</code></pre>
<p>하지만, 실제 러스트의 future는 <code>.await</code>될 때까지 아무것도 하지 않습니다. 따라서,
위의 두 코드 스니펫들은 둘 다 <code>book_future</code>와 <code>music_future</code>를 동시가 아닌
순차적으로 실행한다는 의미입니다. 두 future를 진짜 동시에 실행하려면
<code>futures::join!</code>을 사용하세요:</p>
<pre><code class="language-rust edition2018 ignore">use futures::join;

async fn get_book_and_music() -&gt; (Book, Music) {
    let book_fut = get_book();
    let music_fut = get_music();
    join!(book_fut, music_fut)
}
</code></pre>
<p><code>join!</code>이 반환한 값은 각 <code>Future</code>가 출력한 값으로 구성된 튜플입니다.</p>
<h2><a class="header" href="#try_join" id="try_join"><code>try_join!</code></a></h2>
<p><code>Result</code>를 반환하는 future들에는 <code>join!</code>말고 <code>try_join!</code>을 사용하는 게 좋습니다.
<code>join!</code>은 모든 하위 future들이 완성되었을 때에만 완성되므로, 하위 future 들 중
하나가 <code>Err</code>을 반환하였더라도 나머지 future들을 계속 처리할 것입니다. </p>
<p><code>join!</code>과 다르게, <code>try_join!</code>은 하위 future 중 하나가 에러를 반환하면 즉시 완성될 것입니다.</p>
<pre><code class="language-rust edition2018 ignore">use futures::try_join;

async fn get_book() -&gt; Result&lt;Book, String&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book();
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
</code></pre>
<p><code>try_join!</code>에 전달된 future들은 모두 같은 타입의 에러를 반환해야 한다는 점을
명심하세요. 에러 타입을 일치시키기 위해 <code>futures::future::TryFutureExt</code> 모듈의
<code>.map_err(|e| ...)</code>과 <code>.err_into()</code> 함수를 사용해 보세요.</p>
<pre><code class="language-rust edition2018 ignore">use futures::{
    future::TryFutureExt,
    try_join,
};

async fn get_book() -&gt; Result&lt;Book, ()&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book().map_err(|()| &quot;Unable to get book&quot;.to_string());
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
</code></pre>
<h1><a class="header" href="#select" id="select"><code>select!</code></a></h1>
<p><code>futures::select</code> 매크로를 사용하면 여러 future를 동시에 실행하면서, 어떤
future라도 완성되면 사용자가 바로 반응할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::FutureExt, // `.fuse()`에 필요
    pin_mut,
    select,
};

async fn task_one() { /* ... */ }
async fn task_two() { /* ... */ }

async fn race_tasks() {
    let t1 = task_one().fuse();
    let t2 = task_two().fuse();

    pin_mut!(t1, t2);

    select! {
        () = t1 =&gt; println!(&quot;task one completed first&quot;),
        () = t2 =&gt; println!(&quot;task two completed first&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>위의 함수는 <code>t1</code>과 <code>t2</code> 둘 다 동시에 실행할 것입니다. 둘 중에 하나가 끝나면,
대응하는 핸들러가 <code>println!</code>을 호출하고, 위 함수는 나머지 태스크를 완성하지 않고
바로 종료됩니다.</p>
<p><code>select</code>의 기본 문법은 <code>&lt;pattern&gt; = &lt;expression&gt; =&gt; &lt;code&gt;,</code>이고, <code>select</code>에
넣을 future 개수만큼 반복하면 됩니다.</p>
<h2><a class="header" href="#default---와-complete--" id="default---와-complete--"><code>default =&gt; ...</code> 와 <code>complete =&gt; ...</code></a></h2>
<p>또한 <code>select</code>는 <code>default</code>와 <code>complete</code> 분기를 지원합니다.</p>
<p><code>default</code> 분기는 <code>select</code>에 넣어진 future들 중 아무것도 완성되지 않았으면
실행됩니다. 따라서 <code>default</code> 분기가 있는 <code>select</code>는 항상 즉시 반환합니다. 다른
어떤 future도 준비되지 않았으면 <code>defualt</code>가 실행되기 때문입니다.</p>
<p><code>complete</code> 분기는 <code>select</code>에 넣어진 모든 future가 모두 완성되어 더 이상 진행할
일이 없는 경우를 다루기 위해 사용됩니다. <code>complete</code> 분기는 <code>select!</code>를 반복문
안에 넣을 때 유용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{future, select};

async fn count() {
    let mut a_fut = future::ready(4);
    let mut b_fut = future::ready(6);
    let mut total = 0;

    loop {
        select! {
            a = a_fut =&gt; total += a,
            b = b_fut =&gt; total += b,
            complete =&gt; break,
            default =&gt; unreachable!(), // 실행되지 않음(future들은 준비되자마자 완성됨)
        };
    }
    assert_eq!(total, 10);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unpin과-fusedfuture로-상호작용하기" id="unpin과-fusedfuture로-상호작용하기"><code>Unpin</code>과 <code>FusedFuture</code>로 상호작용하기</a></h2>
<p>위 첫 번째 예제에서, 여러분은 두 <code>async fn</code>가 반환한 future에 대해 <code>pin_mut</code>으로
고정하고, <code>.fuse()</code>를 호출해야 한다는 점을 인지했을 겁니다. <code>select</code>안에서
사용된 future들은 <code>Unpin</code>, <code>FusedFuture</code> 트레잇 둘 다 구현해야 하기 때문에, 이
호출들이 필요합니다.</p>
<p><code>select</code>가 사용하는 future는 값으로 전달되지 않고 가변 참조로 전달되기 때문에,
<code>Unpin</code>이 필요합니다. future의 소유권을 취하지 않기 때문에, 미완성된 future는
<code>select</code>를 호출한 다음에도 재사용 할 수 있습니다.</p>
<p>비슷하게, <code>select</code>는 이미 완성된 future를 poll하면 안되기 때문에, <code>FusedFuture</code>
트레잇이 필요합니다. <code>FusedFuture</code>는 future에 의해 구현되며, 자신이 완성되었는지
여부를 추적합니다. <code>FusedFuture</code>는 아직 완성되지 않은 future만 골라서 폴링할 수
있게 해주기 때문에 <code>select</code>를 반복문 안에서 사용할 수 있게 됩니다. 이는 위
예제에서 <code>a_fut</code>이나 <code>b_fut</code>가 반복문 2회차 때에 완성되는 것을 보면 알 수
있습니다. <code>future::ready</code>가 반환한 future가 <code>FusedFuture</code>를 구현하기 때문에,
<code>select</code>가 그 future를 다시 poll하지 못하게 할 수 있습니다.</p>
<p>스트림은 같은 기능을 하는 <code>FusedStream</code> 트레잇을 가지고 있음을 알아두세요.
<code>FusedStream</code> 트레잇을 구현하거나, <code>.fuse()</code>를 사용하여 래핑한 스트림은
<code>.next()</code> / <code>.try_next()</code>을 통해 <code>FusedFuture</code>를 뱉을 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    stream::{Stream, StreamExt, FusedStream},
    select,
};

async fn add_two_streams(
    mut s1: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
    mut s2: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
) -&gt; u8 {
    let mut total = 0;

    loop {
        let item = select! {
            x = s1.next() =&gt; x,
            x = s2.next() =&gt; x,
            complete =&gt; break,
        };
        if let Some(next_num) = item {
            total += next_num;
        }
    }

    total
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#fuse와-futuresunordered를-이용한-select-루프-내부에서의-동시적-태스크" id="fuse와-futuresunordered를-이용한-select-루프-내부에서의-동시적-태스크"><code>Fuse</code>와 <code>FuturesUnordered</code>를 이용한 <code>select</code> 루프 내부에서의 동시적 태스크</a></h2>
<p><code>Fuse:terminated()</code> 함수는 눈에 잘 띄지는 않지만 유용한 함수입니다. 이 함수는
이미 종료되어 비어있지만, 나중에 필요할 때, 실행할 future를 넣어서 실행할 수 있는
future를 만들어 줍니다.</p>
<p>이 함수는 <code>select</code> 루프가 유효한 동안에 실행될 필요가 있지만 <code>select</code> 루프 자체
안에서 만들어지는 태스크가 있을 경우 유용합니다.</p>
<p><code>.select_next_some()</code> 함수의 용도에 유의하세요. 이 함수는 스트림이 반환한
<code>Some(_)</code> 값에 대응하는 분기를 실행할 때만 <code>select</code>와 함께 사용될 수 있고.
<code>None</code>은 무시할 겁니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) { /* ... */ }

async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let run_on_new_num_fut = run_on_new_num(starting_num).fuse();
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(run_on_new_num_fut, get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                // 타이머가 경과되었음. 아직 실행되지 않고 있는 future가 있다면,
                // 새 `get_new_num_fut`를 시작
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                // 새 숫자가 도착함-- 새 `run_on_new_num_fut`를 시작하고 예전
                // 것을 드랍함.
                run_on_new_num_fut.set(run_on_new_num(new_num).fuse());
            },
            // `run_on_new_num_fut`를 실행
            () = run_on_new_num_fut =&gt; {},
            // 모든 future가 완성되었다면 패닉. 왜냐하면 `indefinitely`는 값들을
            // 무기한으로 내야(yield) 함
            complete =&gt; panic!(&quot;`interval_timer` completed unexpectedly&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>같은 future의 여러 복사본을 동시에 실행할 필요가 있을 때에는 <code>FuturesUnordered</code>
타입을 사용하세요. 아래 예제는 위 예제랑 비슷하지만, <code>run_on_new_num_fut</code>의
복사본이 생겨도 중단하지 않고 각 복사본을 완성될때까지 실행한다는 점이 다릅니다.
또한, 아래 예제는 <code>run_on_new_num_fut</code>가 반환한 값을 출력할 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, FuturesUnordered, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) -&gt; u8 { /* ... */ 5 }

// `get_new_num`로부터 나온 마지막 숫자를 가지고 `run_on_new_num`를 실행
//
// `get_new_num`은 타이머가 경과될 때마다 즉시 현재 실행중인 `run_on_new_num`을
// 취소하고 새 반환값으로 대체하면서 재시작됨.
async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let mut run_on_new_num_futs = FuturesUnordered::new();
    run_on_new_num_futs.push(run_on_new_num(starting_num));
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                // 타이머 경과됨. 실행중인 `get_new_num_fut`이 없다면 새로
                // 시작함.
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                // 새 숫자가 도착함-- 새 `run_on_new_num_fut`를 시작함.
                run_on_new_num_futs.push(run_on_new_num(new_num));
            },
            // `run_on_new_num_futs`를 실행하고 완성된 `run_on_new_num_futs`가
            // 있는 지 확인함
            res = run_on_new_num_futs.select_next_some() =&gt; {
                println!(&quot;run_on_new_num_fut returned {:?}&quot;, res);
            },
            // 모든 것이 완성되었다면 패닉. 왜냐하면 `interval_timer`는 값을 무기한으로 내야 함
            complete =&gt; panic!(&quot;`interval_timer` completed unexpectedly&quot;),
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#알아두면-좋을-요령들" id="알아두면-좋을-요령들">알아두면 좋을 요령들</a></h1>
<p>러스트의 <code>async</code> 지원은 아직 많이 새롭습니다. 그리고 매우 필요한 몇몇 기능들은
아직 개발중에 있습니다. 진단루틴도 약간 수준이하입니다. 이 장에서는 자주 나오는
불편한 부분들에 대해 논의하고, 이를 회피하는 요령에 대해 설명합니다.</p>
<h1><a class="header" href="#async-블록-안에서의-" id="async-블록-안에서의-"><code>async</code> 블록 안에서의 <code>?</code></a></h1>
<p><code>async fn</code> 안에서와 마찬가지로, <code>async</code> 블록들 안에서 <code>?</code>의 사용도 보편적입니다.
하지만, <code>async</code> 블록의 반환 타입은 명시적으로 규정되지 않았기 때문에, 컴파일러가
<code>async</code>블록의 에러 타입을 추론하는 데 실패할 것입니다.</p>
<p>예를 들어, 아래 코드는</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyError;
</span><span class="boring">async fn foo() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span><span class="boring">async fn bar() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span>let fut = async {
    foo().await?;
    bar().await?;
    Ok(())
};
<span class="boring">}
</span></code></pre></pre>
<p>아래 에러를 발생시킬 것입니다.</p>
<pre><code>error[E0282]: type annotations needed
 --&gt; src/main.rs:5:9
  |
4 |     let fut = async {
  |         --- consider giving `fut` a type
5 |         foo().await?;
  |         ^^^^^^^^^^^^ cannot infer type
</code></pre>
<p>불행하게도, &quot;<code>fut</code>에 타입을 부여하는&quot; 방법이나, 명시적으로 <code>async</code>블록의 반환
타입을 지정하는 방법은 현재 존재하지 않습니다. 이 문제를 해결하기 위해서,
<code>async</code>블록에 성공과 에러의 타입을 제공하기 위해 아래와 같이 &quot;turbofish&quot;
연산자를 사용하세요.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyError;
</span><span class="boring">async fn foo() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span><span class="boring">async fn bar() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span>let fut = async {
    foo().await?;
    bar().await?;
    Ok::&lt;(), MyError&gt;(()) // &lt;- 이 곳의 명시적 타입 주해에 유의할 것.
};
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#send-추정" id="send-추정"><code>Send</code> 추정</a></h1>
<p>몇몇 <code>async fn</code> 상태기계는 스레드 간 이동에 안전하지만 나머지는 그렇지 않습니다.
<code>async fn</code> <code>Future</code>가 <code>Send</code>인지 여부는 <code>Send</code>가 아닌 타입이 <code>.await</code>의 위치
앞뒤로 걸쳐서 유지되는지 여부에 달려 있습니다. 값들이 <code>.await</code>의 위치 앞뒤로
걸쳐서 유지될 가능성이 있을 때, 컴파일러는 <code>async fn</code> <code>Future</code>가 <code>Send</code>인지
여부를 추정하려고 최선을 다합니다. 하지만, 이런 분석은 오늘날 많은 경우에 너무
보수적입니다.</p>
<p>예를 들어, 간단한 비(非) <code>Send</code> 타입이 <code>Rc</code>를 가지고 있을지도 모른다고
가정해봅시다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Default)]
struct NotSend(Rc&lt;()&gt;);
<span class="boring">}
</span></code></pre></pre>
<p><code>async fn</code>이 최종적으로 반환한 <code>Future</code> 타입(역주: 아래 예제에서 foo()가 반환한
future)이 <code>Send</code>이어야만 하는 경우에도, <code>NotSend</code> 타입의 변수들이 임시값이라면
<code>async fn</code> 안에서도 간편하게 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::rc::Rc;
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct NotSend(Rc&lt;()&gt;);
</span>async fn bar() {}
async fn foo() {
    NotSend::default();
    bar().await;
}

fn require_send(_: impl Send) {}

fn main() {
    require_send(foo());
}
</code></pre></pre>
<p>하지만, <code>foo</code>를 수정하여 한 변수 안에 <code>NotSend</code>를 저장하는 코드를 추가한다면, 이
예제는 컴파일되지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::rc::Rc;
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct NotSend(Rc&lt;()&gt;);
</span><span class="boring">async fn bar() {}
</span>async fn foo() {
    let x = NotSend::default();
    bar().await;
}
<span class="boring">fn require_send(_: impl Send) {}
</span><span class="boring">fn main() {
</span><span class="boring">   require_send(foo());
</span><span class="boring">}
</span></code></pre></pre>
<pre><code>error[E0277]: `std::rc::Rc&lt;()&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:15:5
   |
15 |     require_send(foo());
   |     ^^^^^^^^^^^^ `std::rc::Rc&lt;()&gt;` cannot be sent between threads safely
   |
   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc&lt;()&gt;`
   = note: required because it appears within the type `NotSend`
   = note: required because it appears within the type `{NotSend, impl std::future::Future, ()}`
   = note: required because it appears within the type `[static generator@src/main.rs:7:16: 10:2 {NotSend, impl std::future::Future, ()}]`
   = note: required because it appears within the type `std::future::GenFuture&lt;[static generator@src/main.rs:7:16: 10:2 {NotSend, impl std::future::Future, ()}]&gt;`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `impl std::future::Future`
note: required by `require_send`
  --&gt; src/main.rs:12:1
   |
12 | fn require_send(_: impl Send) {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>이 에러는 문제를 정확히 나타내 줍니다. <code>x</code>를 변수에 저장한다면, <code>x</code>는 <code>async fn</code>이 다른 스레드에서 동작하고 있을 시점인 <code>.await</code>를 지난 다음에야 드랍될
것입니다. <code>Rc</code>는 <code>Send</code>가 아니기 때문에, <code>Rc</code>가 스레드 사이를 이동하게 만드는
것은 위험합니다. 이에 대한 간단한 해법은 <code>.await</code>이전에 <code>Rc</code>를 <code>drop</code>하는
것입니다만, 불행하게도 지금은 해당되지 않습니다.</p>
<p>이 이슈를 해결하기 위해서는, 모든 비 <code>Send</code> 변수를 캡슐화하는 블록 범위를
도입해야 할 것입니다. 이렇게 하면, 이 변수들이 <code>.await</code> 포인트에 걸쳐 존재하지
않는다는 사실을 컴파일러가 알게 하기 쉽습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::rc::Rc;
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct NotSend(Rc&lt;()&gt;);
</span><span class="boring">async fn bar() {}
</span>async fn foo() {
    {
        let x = NotSend::default();
    }
    bar().await;
}
<span class="boring">fn require_send(_: impl Send) {}
</span><span class="boring">fn main() {
</span><span class="boring">   require_send(foo());
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#재귀" id="재귀">재귀</a></h1>
<p>내부적으로, <code>async fn</code>은 <code>.await</code>하는 하위 <code>Future</code>를 갖는 상태기계 타입을
만듭니다. 때문에, <code>async fn</code>을 재귀적으로 사용하기 살짝 까다롭습니다. 왜냐하면,
결과를 도출할 상태기계 타입이 그 자신을 포함해야 하기 때문입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">async fn step_one() { /* ... */ }
</span><span class="boring">async fn step_two() { /* ... */ }
</span><span class="boring">struct StepOne;
</span><span class="boring">struct StepTwo;
</span>// This function:
async fn foo() {
    step_one().await;
    step_two().await;
}
// generates a type like this:
enum Foo {
    First(StepOne),
    Second(StepTwo),
}

// So this function:
async fn recursive() {
    recursive().await;
    recursive().await;
}

// generates a type like this:
enum Recursive {
    First(Recursive),
    Second(Recursive),
}
<span class="boring">}
</span></code></pre></pre>
<p>위 예제는 무한한 크기의 타입을 만들기 때문에 작동하지 않습니다. 컴파일러 오류는 다음과 같습니다.</p>
<pre><code>error[E0733]: recursion in an `async fn` requires boxing
 --&gt; src/lib.rs:1:22
  |
1 | async fn recursive() {
  |                      ^ an `async fn` cannot invoke itself directly
  |
  = note: a recursive `async fn` must be rewritten to return a boxed future.
</code></pre>
<p>제대로 작동하게 하기 위해서는, <code>Box</code>를 이용해 우회접근해야 합니다. 불행하게도,
컴파일러의 제한에 따라 <code>Box::pin</code>으로 <code>recursive()</code> 호출을 감싸는 것만으로는
충분하지 않습니다. 제대로 하려면은, 아래 예제처럼 <code>recursive</code>를 <code>.boxed()</code>된 비
<code>async</code> 블록 안에 넣어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::future::{BoxFuture, FutureExt};

fn recursive() -&gt; BoxFuture&lt;'static, ()&gt; {
    async move {
        recursive().await;
        recursive().await;
    }.boxed()
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#트레잇-내부의-async" id="트레잇-내부의-async">트레잇 내부의 <code>async</code></a></h1>
<p>현재로서는, 트레잇 안에서 <code>async fn</code>를 사용할 수 없습니다. 이유가 좀 복잡한데,
향후 이 제약을 해소하기 위한 계획이 있긴 합니다.</p>
<p>Rust가 언어 차원에서 공식지원하기 전 까지는, <a href="https://github.com/dtolnay/async-trait">crates.io에 있는 async-trait 크레잇</a>으로 트레잇 안에서 <code>async fn</code>을 사용하면 됩니다.</p>
<p><a href="https://github.com/dtolnay/async-trait">crates.io에 있는 async-trait 크레잇</a>
메소드는 매 함수호출마다 힙영역에 할당할 것입니다. 이 때 발생하는 성능저하가
전체 어플리케이션에 비하면 별로 대단한 것은 아니지만, 초당 수백만 회의 호출이
예상되는 저수준 공용 API에 사용할 때에는 염두에 두어야 합니다.</p>
<h1><a class="header" href="#비동기-생태계" id="비동기-생태계">비동기 생태계</a></h1>
<p>러스트는 현재 비동기 코드를 작성하는 데 극히 필수적인 기능만 제공하고 있습니다.
중요한 것은, 실행자, 태스크, 반응자, 조합자, 그리고 저수준 입출력 future와
트레잇은 아직 표준 라이브러리에서 제공되지 않고 있습니다. 하지만, 커뮤니티에서
제공하는 비동기 생태계가 이러한 갭을 메꾸고 있습니다. </p>
<h2><a class="header" href="#비동기-런타임" id="비동기-런타임">비동기 런타임</a></h2>
<p>비동기 런타임은 비동기 어플리케이션을 실행하는 데 사용되는 라이브러리들입니다.
런타임들은 보통 한 개의 <em>반응자</em>와 한 개 이상의 <em>실행자</em>를 포함합니다.  반응자는
비동기 입출력, 프로세스 간 통신 그리고 타이머 같은 외부 이벤트에 대한 구독
메카니즘을 제공합니다.  통상적으로 비동기 런타임에서 구독자는 저수준 입출력
연산을 나타내는 future를 말합니다.  실행자는 태스크들의 스케쥴링과 실행을
처리합니다. 실행자는 태스크의 실행과 일시정지를 계속 추적하고, future를
완성될때까지 poll하고, 또, task가 진행할 수 있을 때 깨우는 역할을 합니다.
&quot;실행자(excutor)&quot;라는 용어는 &quot;runtime&quot;과 자주 혼용됩니다.  여기서는 호환되는
트레잇과 기능들이 묶음포장된 런타임을 가리키는 용어로 &quot;생태계(ecosystem)&quot;를
사용할 것입니다.</p>
<h2><a class="header" href="#커뮤니티에서-제공하는-비동기-크레잇들" id="커뮤니티에서-제공하는-비동기-크레잇들">커뮤니티에서 제공하는 비동기 크레잇들</a></h2>
<h3><a class="header" href="#future-크레잇" id="future-크레잇">future 크레잇</a></h3>
<p><a href="https://docs.rs/futures/"><code>futures</code> crate</a> 은 비동기 코드를 작성하는 데 유용한
트레잇과 함수를 포함하고 있습니다. <code>future</code> 크레잇은 <code>Stream</code>, <code>Sing</code>,
<code>AsyncRead</code>, <code>AsyncWrite</code> 트레잇 및 조합자 같은 유틸리티들을 포함합니다.  이
유틸리티들과 트레잇들은 아마 결국에는 표준 라이브러리에 포함될 것입니다.</p>
<p><code>futures</code> 크레잇은 고유의 실행자를 가지고 있지만, 고유의 반응자는 없습니다.
그래서 <code>futures</code> 크레잇은 비동기 입출력이나 타이머 future의 실행은 지원하지
않습니다.</p>
<p>이 같은 이유로, <code>futures</code> 크레잇은 온전한 런타임으로 여겨지지 않습니다.
<code>futures</code> 크레잇의 유틸리티를 다른 크레잇의 실행자와 함께 사용하는 것이 일반적인
선택지입니다.</p>
<h3><a class="header" href="#인기있는-비동기-런타임" id="인기있는-비동기-런타임">인기있는 비동기 런타임</a></h3>
<p>표준 라이브러리에는 비동기 런타임이 전혀 없고, 어느것도 공식적으로 추천되지
않습니다.  다음 크레잇들은 인기있는 런타임들을 제공합니다.</p>
<ul>
<li><a href="https://docs.rs/tokio/">Tokio</a>: HTTP, gRPC, 추적 프레임웍을 제공하는 인기있는
비동기 생태계</li>
<li><a href="https://docs.rs/async-std/">async-std</a>: 표준 라이브러리 비동기 컴포넌트에
대응하는 크레잇</li>
<li><a href="https://docs.rs/smol/">smol</a>: 작고 간단한 비동기 런타임으로, <code>UnixStream</code>이나
<code>TcpListener</code> 같은 구조체를 래핑하는 데 사용되는 <code>Async</code> 트레잇을 제공함</li>
<li><a href="https://fuchsia.googlesource.com/fuchsia/+/master/src/lib/fuchsia-async/">fuchsia-async</a>:
Fuchsia 운영체제에서 사용되는 실행자</li>
</ul>
<h2><a class="header" href="#생태계-호환성-결정하기" id="생태계-호환성-결정하기">생태계 호환성 결정하기</a></h2>
<p>모든 비동기 어플리케이션, 프레임웍, 라이브러리들이 서로 호환되는 것은 아니며,
어떤 운영체제나 플랫폼에도 호환되지 않을 수도 있습니다. 대부분의 비동기 코드는
어떤 생태계와도 호환되지만, 몇몇 프레임웍과 라이브러리는 특정 생태계를
요구하기도 합니다. 생태계 요구조건이 항상 문서화되는 것은 아니지만, 라이브러리,
트레잇, 함수가 어떤 생태계에 의존하는지 판단할 수 있는 몇가지 경험칙들이
있습니다.</p>
<p>비동기 입출력, 타이머, 프로세스 또는 태스크 간 통신과 상호작용하는 모든 비동기
코드는 보통 특정 비동기 실행자 또는 반응자에 의존합니다. 그 외 모든 코드, 즉
비동기 표현식, 조합자, 동기화 타입, 스트림 등은 보통 생태계로부터 독립적이고,
중첩된 futures들도 역시 생태계 독립적입니다. 프로젝트를 시작하기 전에, 연관된
비동기 프레임웍과 라이브러리가 서로 호환되는 지, 여러분이 선택한 런타임과는
호환되는 지를 확실히 확인하기를 추천합니다.</p>
<p>특히, <code>Tokio</code>는 <code>mio</code> 반응자를 사용하고, <code>AsyncRead</code>, <code>AsyncWrite</code>을 포함한
비동기 입출력 트레잇의 고유 버전을 정의합니다. <code>Tokio</code> 고유의 구현 때문에,
<a href="https://docs.rs/async-executor"><code>async-executor</code> crate</a>에 의존하는
<code>async-std</code>와 <code>smol</code>과 호환되지 않고, <code>futures</code>에 정의된 <code>AsyncRead</code>와
<code>AsyncWrite</code> 트레잇과도 호환되지 않습니다.</p>
<p>런타임 요구사항 충돌 문제는 때때로 런타임 안에서 다른 런타임을 호출할 수 있게
해주는 호환성 레이어를 통해 해결될 수 있습니다. 예를 들어, <a href="https://docs.rs/async_compat"><code>async_compat</code>
crate</a>은 <code>Tokio</code>와 다른 런타임 사이에서 호환성
레이어를 제공합니다.</p>
<p>비동기 API들을 노출하는 라이브러리는 태스크를 생성하거나 라이브러리 고유의
비동기 입출력이나 타이머 future를 정의하지 않는 한, 특정한 실행자나 반응자에
의존해서는 안됩니다.  이상적으로는, 오직 바이너리들만 태스크의 스케줄링과 실행을
책임져야 합니다.</p>
<h2><a class="header" href="#싱글-스레딩-vs-멀티-스레딩-실행자" id="싱글-스레딩-vs-멀티-스레딩-실행자">싱글 스레딩 vs 멀티 스레딩 실행자</a></h2>
<p>비동기 실행자는 싱글 또는 멀티 스레딩이 될 수 있습니다. 예를 들어,
<code>async-executor</code> 크레잇은 싱글 스레딩 <code>LocalExecutor</code>와 멀티 스레딩 <code>Executor</code>를
모두 제공합니다.</p>
<p>멀티 스레딩 실행자는 여러 태스크들을 동시에 진행시킵니다. 멀티 스레딩 실행자는
많은 태스크가 존재하는 워크로드에서 실행속도를 크게 높일 수 있습니다만, 보통
태스크 간 데이터 동기화의 오버헤드가 큰 편입니다.  싱글스레드와 멀티스레드
런타임 중 하나를 선택할 때, 성능을 측정해 비교해 볼 것을 권합니다.</p>
<p>태스크는 태스크가 만들어진 스레드와 별도의 스레드 모두에서 실행될 수 있습니다.
비동기 런타임은 보통 별도의 스레드에 태스크를 생성하는 기능을 제공합니다. 만약
태스크가 별도의 스레드에서 실행된다면, 그 태스크들도 여전히 논블로킹이어야
합니다.  태스크들을 멀티 스레딩 실행자에서 스케줄링하기 위해, 그 태스크들은 역시
<code>Send</code>이어야 합니다. 몇몇 런타임들은 생성된 스레드 안에서 실행됨이 보장되는 비
<code>Send</code> 태스크들을 생성하는 기능을 제공합니다. 그런 런타임들은 또한 전용
스레드에서 실행되는 블로킹 태스크들을 생성하는 기능을 제공할 것입니다. 전용
스레드에서 실행되는 블로킹 태스크는 다른 라이브러리의 블로킹 동기적 코드를
실행하는 데 유용하게 사용될 수 있습니다.</p>
<h1><a class="header" href="#마지막-프로젝트-비동기-러스트로-동시성-웹-서버-만들기" id="마지막-프로젝트-비동기-러스트로-동시성-웹-서버-만들기">마지막 프로젝트: 비동기 러스트로 동시성 웹 서버 만들기</a></h1>
<p>이 장에선, 비동기 러스트로 러스트북의 <a href="https://rinthel.github.io/rust-lang-book-ko/ch20-01-single-threaded.html">싱글스레드 기반 웹 서버
만들기</a>
를 수정하여 여러개의 요청을 동시에 수행할 수 있게 할 것입니다.</p>
<h2><a class="header" href="#개요" id="개요">개요</a></h2>
<p>이 강좌가 끝나면 아래 코드가 만들어 질 것입니다.</p>
<p><code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    // localhost 7878 포트에서 수신되는 TCP 연결을 listen하기
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    // 영원히 블록하면서, 이 IP 주소로 들어오는 요청을 처리
    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    // 처음 1024 바이트의 데이터를 스트림으로부터 읽어들임
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    // 요청 안의 데이터에 따라 환영인사로 응답하거나 404 에러
    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };
    let contents = fs::read_to_string(filename).unwrap();

    // 다시 스트림에 응답을 씀
    // 클라이언트에게 응답이 전송될 수 있게 스트림을 플러시함
    let response = format!(&quot;{}{}&quot;, status_line, contents);
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><code>hello.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>404.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>cargo run</code>으로 서버를 실행시켜서 브라우저에서 <code>127.0.0.1:7878</code>에 접속했다면,
페리스의 친근한 인사말을 볼 수 있을 겁니다!</p>
<h1><a class="header" href="#비동기-코드-실행하기" id="비동기-코드-실행하기">비동기 코드 실행하기</a></h1>
<p>HTTP 서버는 동시에 여러 클라이언트에 동시에 서비스할 수 있어야 합니다. 즉, HTTP
서버는 현재의 요청을 처리하기 전에 기존의 요청이 끝나길 기다려서는 안된다는
말입니다. 러스트북의 예제에서는 모든 연결에 스레드를 하나씩 할당하는 스레드 풀을
만들어서 <a href="https://rinthel.github.io/rust-lang-book-ko/ch20-02-multithreaded.html#%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0">이 문제를
해결합니다.</a></p>
<p>여기서는, 스레드를 추가하여 처리성능을 향상시키기 보다, 비동기 코드를 사용하여
같은 효과를 내 봅시다.</p>
<p><code>handle_connection</code>의 선언을 <code>async fn</code>으로 수정하여 future를 반환하게 합시다.</p>
<pre><code class="language-rust ignore">async fn handle_connection(mut stream: TcpStream) {
    //&lt;-- snip --&gt;
}
</code></pre>
<p><code>async</code>를 <code>handle_connection</code> 선언에 추가하면 반환값이 유닛 타입 <code>()</code>에서
<code>Future&lt;Output=()&gt;</code>을 구현하는 타입으로 변경됩니다.</p>
<p>이 코드를 컴파일하면 작동되지 않을 것이라는 컴파일러 에러가 발생합니다.</p>
<pre><code class="language-console">$ cargo check
    Checking async-rust v0.1.0 (file:///projects/async-rust)
warning: unused implementer of `std::future::Future` that must be used
  --&gt; src/main.rs:12:9
   |
12 |         handle_connection(stream);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: futures do nothing unless you `.await` or poll them
</code></pre>
<p><code>handle_connection</code>은 그 반환값을 <code>await</code>하거나 <code>poll</code>하지 않았기 때문에, 전혀
실행되지 않을 것입니다. 서버를 실행하고 브라우저에서 <code>127.0.0.1:7878</code> 열면
연결이 거부됨을 알 수 있습니다. 서버가 요청을 처리하지 않는 것입니다.</p>
<p>비동기 코드 그 자체 안에서 <code>await</code>하거나 <code>poll</code>할 수는 없습니다. future를
완성될때까지 스케쥴링하고 실행할 비동기 런타임이 필요합니다. 비동기 런타임,
executor 그리고 reactor에 대한 자세한 정보를 원한다면 <a href="09_example/../08_ecosystem/00_chapter.html">런타임
선택하기</a> 장을 살펴보세요.</p>
<h2><a class="header" href="#async-런타임-추가" id="async-런타임-추가">Async 런타임 추가</a></h2>
<p>여기서는 <code>async-std</code> 크레잇의 executor를 사용할 것입니다.
<code>async-std</code>의 <code>#[async_std::main]</code> 속성을 붙이면 비동기 main 함수를 작성할 수 있습니다.
<code>#[async_std::main]</code>을 사용하기 위해서 <code>async-std</code>의 <code>attributes</code> 기능을 <code>Cargo.toml</code>에서
활성화 하세요.</p>
<pre><code class="language-toml">[dependencies.async-std]
version = &quot;1.6&quot;
features = [&quot;attributes&quot;]
</code></pre>
<p>첫 번째 단계로, main 함수를 비동기로 전환하고, 비동기 <code>handle_connection</code>이
반환한 future를 <code>await</code>할 것입니다. 그리고 나서, 서버가 어떻게 작동하는 지
테스트할 것입니다. 이렇게 작성한 코드는 아래와 같습니다.</p>
<pre><pre class="playground"><code class="language-rust#[async_std::main]">async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        // 경고: 동시성이 없습니다.
        handle_connection(stream).await;
    }
}``` 
이제 서버가 연결을 동시에 처리할 수 있는 지 테스트해 봅시다. 단순히 `handle_connection`을
비동기로 만들었다고 해서 바로 서버가 여러개의 연결을 동시에 처리할 수 있게
되지는 않습니다. 곧 그 이유를 곧 알게 될 것입니다.

이를 설명하기 위해, 느린 요청 하나로 모의실험해 봅시다.
클라이언트가 `127.0.0.1:7878/sleep`으로 요청을 보냈을 때, 우리 서버는 5초간 잠들 것입니다.

```rust,ignore
use async_std::task;

async fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        task::sleep(Duration::from_secs(5)).await;
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };
    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p>이는 러스트북의 <a href="https://rinthel.github.io/rust-lang-book-ko/ch20-02-multithreaded.html#%ED%98%84%EC%9E%AC-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-%EB%8A%90%EB%A6%B0-%EC%9A%94%EC%B2%AD%EC%9D%84-%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%ED%8C%85%ED%95%98%EA%B8%B0">현재 서버에서 느린 요청을
시뮬레이팅하기</a>와
매우 유사합니다.</p>
<p>우리는 블로킹 함수인 <code>std::thread::sleep</code>대신에 논블로킹 함수인
<code>async_std::task::sleep</code>를 사용하고 있습니다. 코드 한 줄이라도 <code>async fn</code> 안에서
실행되고, <code>await</code>된다면 그 코드는 여전히 스레드를 블록할 수도 있음을 명심하세요.
우리 서버가 연결을 동시에 처리할 수 있는 지 테스트하려면, <code>handle_connection</code>이
논블로킹임을 확인해야 합니다.</p>
<p>서버를 실행하면, <code>127.0.0.1:7878/sleep</code>에 대한 한 개의 요청이 수신되는 다른
요청들을 5초간 블록하는 것을 확인할 수 있습니다! 그 이유는 우리가
<code>handle_connection</code>을 <code>await</code>하는 동안에 진행될만한 다른 동시성 태스크가 없기
때문입니다. 다음 장에서는 연결을 동시에 처리할 수 있는 비동기 코드를 작성하는
방법에 대해 알아 봅시다.</p>
<h1><a class="header" href="#연결을-동시에-처리하기" id="연결을-동시에-처리하기">연결을 동시에 처리하기</a></h1>
<p>지금까지 우리 코드의 문제는 <code>listener.incoming()</code>이 블록하는 반복자라는 점입니다.
executor는 <code>listener</code>가 수신 연결을 기다리는 동안 다른 future를 실행할 수 없고,
우리는 이전 연결을 다 처리할 때까지 새로운 연결을 처리할 수 없습니다.</p>
<p>이를 고치기 위해서 블록하는 반복자인 <code>listener.incoming()</code>을 블록하지 않는 Stream으로
전환시킬 것입니다. Stream은 반복자와 비슷하지만, 비동기적으로 소비될 수
있습니다. 더 많은 정보를 원하시면, <a href="09_example/../05_streams/01_chapter.html">Stream 관련
장</a>을 보세요.</p>
<p>블록하는 <code>std::net:TcpListener</code>를 블록하지 않는 <code>async_std::net::TcpListener</code>로
바꿔봅시다. 그리고 <code>async_std::net::TcpStream</code>을 받을 수 있게
<code>handle_connection</code>을 수정합시다. </p>
<pre><code class="language-rust ignore">use async_std::prelude::*;

async fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).await.unwrap();

    //&lt;-- snip --&gt;
    stream.write(response.as_bytes()).await.unwrap();
    stream.flush().await.unwrap();
}
</code></pre>
<p><code>TcpListener</code>의 비동기 버전은 <code>listener.incoming()</code>에 대한 <code>Stream</code>을
구현합니다. 이는 두 가지 이득을 가져다 주는데요, 첫 째는 <code>listener.incoming()</code>이
더 이상 executr를 블록하지 않는다는 점입니다. 이렇게 되면 이제 executor는
처리해야할 수신된 TCP 연결이 없으면 계류중인 future에게 스레드를 양보할 수
있습니다.</p>
<p>두번 째 이득은 Stream에서 가져온 요소들을 Stream의 <code>for_each_concurrent</code> 메소드를
사용하여 선택적으로 동시에 처리할 수 있다는 점입니다.
아래에서는 각 수신된 요구를 동시에 처리하기 위해 이 메소드를 활용할 것입니다.
<code>futures</code> 크레잇의 <code>Stream</code> 트레잇을 import할 필요가 있습니다. 그러면
Cargo.toml은 이제 아래와 같이 될 것입니다.</p>
<pre><code class="language-diff">+[dependencies]
+futures = &quot;0.3&quot;

 [dependencies.async-std]
 version = &quot;1.6&quot;
 features = [&quot;attributes&quot;]
</code></pre>
<p>이제 <code>handle_connection</code>을 클로저 함수 안으로 넣어서 각 연결을 동시에 처리할 수
있습니다. 클로저 함수는 각 <code>TcpStream</code>의 소유권을 획득하고, 새 <code>TcpStream</code>이
준비되자마자 실행됩니다.
<code>handle_connection</code>이 블록하지 않는 한, 더 이상 느린 요청은 다른 요청이 완성되지 못하게
방해하지 않을 것입니다.</p>
<pre><code class="language-rust ignore">use async_std::net::TcpListener;
use async_std::net::TcpStream;
use futures::stream::StreamExt;

#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).await.unwrap();
    listener
        .incoming()
        .for_each_concurrent(/* limit */ None, |tcpstream| async move {
            let tcpstream = tcpstream.unwrap();
            handle_connection(tcpstream).await;
        })
        .await;
}
</code></pre>
<h1><a class="header" href="#리퀘스트를-병렬적으로-대응하기" id="리퀘스트를-병렬적으로-대응하기">리퀘스트를 병렬적으로 대응하기</a></h1>
<p>우리의 예제는 지금까지 (스레드를 사용하는) 병렬성에 대한 대안으로서 (비동기
코드를 사용하여) 광범위하게 동시성을 구현하였습니다. 하지만, 비동기 코드와
스레드는 상호배제적이지 않습니다. 우리의 예제에서, <code>for_each_concurrent</code>는 한
개의 스레드에서 각 연결을 동시적으로 처리합니다. 하지만 <code>async-std</code> 크레잇은
별도의 스레드에서 태스크를 생성하는 기능을 제공합니다. <code>handle_connection</code>은
<code>Send</code>이면서 논블로킹이기 때문에, <code>async_std::task::spawn</code>과 함께 사용하여도
안전합니다. 아래는 이 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust">use async_std::task::spawn;

#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).await.unwrap();
    listener
        .incoming()
        .for_each_concurrent(/* limit */ None, |stream| async move {
            let stream = stream.unwrap();
            spawn(handle_connection(stream));
        })
        .await;
}
</code></pre></pre>
<p>이제 우리는 여러 리퀘스트를 동시에 다루기 위해 동시성과 병행성을 모두 사용하고 있습니다!
더 자세한 내용은 <a href="09_example/../08_ecosystem/00_chapter.html#%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%94%A9-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%94%A9-%EC%8B%A4%ED%96%89%EC%9E%90">멀티스레딩 실행자
장</a>를 참조하세요.</p>
<h1><a class="header" href="#tcp-서버-테스트하기" id="tcp-서버-테스트하기">TCP 서버 테스트하기</a></h1>
<p><code>handle_connection</code> 함수를 테스트해 봅시다.</p>
<p>먼저, 테스트에 사용될 <code>TcpStream</code>이 필요합니다. 단대단이나 통합 테스트에서는
코드 테스트를 위해 실제 TCP 연결이 필요할 수도 있습니다. 실제 TCP 연결을
사용하여 테스트하는 방법 중 하나는 <code>localhost</code>의 0번 포트에서 리스닝하는
것입니다. 0번 포트는 유효한 유닉스 포트가 아니지만 테스트 목적으로는 작동합니다.
운영체제가 열린 TCP 포트를 하나 골라 줄 것입니다.</p>
<p>하지만, 아래 예제에서는 연결 핸들러에 대한 유닛 테스트를 작성하여, 각각의 입력에
맞는 올바른 응답이 반환되었는지 확인할 것입니다. 유닛 테스트를 격리되고
결정론적이게 만들기 위해,  <code>TcpStream</code>을 모조품으로 대체할 것입니다.</p>
<p>먼저, 테스트하기 쉽게 <code>handle_connection</code>의 시그니처를 바꿀
것입니다. 사실 <code>handle_connection</code>는 <code>async_std::net::TcpStream</code>이 꼭 필요한
것은 아닙니다. <code>async_std::io::Read</code>, <code>async_std::io::Write</code>, 그리고 <code>marker::Unpin</code>을 구현하는
어떤 구조체도 가능합니다. 이 내용을 반영하여 타입 시그니처를 바꾸면 모조품을
테스트 용으로 넘겨 줄 수 있게 됩니다.</p>
<pre><code class="language-rust ignore">use std::marker::Unpin;
use async_std::io::{Read, Write};

async fn handle_connection(mut stream: impl Read + Write + Unpin) {
</code></pre>
<p>이 트레잇 세 개를 구현하는 <code>TcpStream</code> 모조품을 만들어 봅시다.
먼저, <code>poll_read</code> 메소드 한 개만 있는 <code>Read</code> 트레잇을 구현합시다.
<code>TcpStream</code> 모조품은 읽기 버퍼로 복사되는 어떤 데이터를 가지고 있을 것이고,
복사가 끝나면 <code>poll_read</code>는 읽기가 끝났음을 알리는 <code>Poll::Ready</code>를 반환할 것입니다.</p>
<pre><code class="language-rust ignore">    use super::*;
    use futures::io::Error;
    use futures::task::{Context, Poll};

    use std::cmp::min;
    use std::pin::Pin;

    struct MockTcpStream {
        read_data: Vec&lt;u8&gt;,
        write_data: Vec&lt;u8&gt;,
    }

    impl Read for MockTcpStream {
        fn poll_read(
            self: Pin&lt;&amp;mut Self&gt;,
            _: &amp;mut Context,
            buf: &amp;mut [u8],
        ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; {
            let size: usize = min(self.read_data.len(), buf.len());
            buf[..size].copy_from_slice(&amp;self.read_data[..size]);
            Poll::Ready(Ok(size))
        }
    }
</code></pre>
<p><code>poll_write</code>, <code>poll_flush</code>, 그리고 <code>poll_close</code>라는 세 개의 메소드를 작성해야
할지라도 <code>Write</code> 구현은 매우 간단합니다.
<code>poll_write</code>는 모든 입력 데이터를 <code>TcpStream</code> 모조품으로 복사하고, 완성되면
<code>Poll::Ready</code>를 반환할 것입니다. <code>TcpStream</code> 모조품을 플러싱하거나 닫기 위한
별도 작업이 필요 없기 때문에 <code>poll_flush</code>와 <code>poll_close</code>는 그냥 <code>Poll::Ready</code>를
반환하면 됩니다.</p>
<pre><code class="language-rust ignore">    impl Write for MockTcpStream {
        fn poll_write(
            mut self: Pin&lt;&amp;mut Self&gt;,
            _: &amp;mut Context,
            buf: &amp;[u8],
        ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; {
            self.write_data = Vec::from(buf);
            return Poll::Ready(Ok(buf.len()));
        }
        fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt; {
            Poll::Ready(Ok(()))
        }
        fn poll_close(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt; {
            Poll::Ready(Ok(()))
        }
    }
</code></pre>
<p>마지막으로, <code>TcpStream</code> 모조품은 메모리 상 위치가 안전하게 움직일 수 있다고
알리는 <code>Unpin</code>을 구현해야 합니다.
<code>Unpin</code>에 대한 자세한 정보는 <a href="09_example/../04_pinning/01_chapter.html">고정하기</a>를 참고하세요.</p>
<pre><code class="language-rust ignore">    use std::marker::Unpin;
    impl Unpin for MockTcpStream {}
</code></pre>
<p>이제 <code>handle_connection</code> 함수를 테스트할 준비가 되었습니다.
<code>MockTcpStream</code>이 임의의 초기 데이터를 가지도록 설정한 다음,
<code>#[async_std::main]</code>의 사용과 유사하게 <code>#[async_std::test]</code> 속성을 이용하여
<code>handle_connection</code>을 실행할 수 있습니다.</p>
<p><code>handle_connection</code>이 잘 작동함을 확인하기 위해 데이터의 처음 부분을 비교하여 데이터가
<code>MockTcpStream</code>에 제대로 쓰여졌는 지 확인할 것입니다.</p>
<pre><code class="language-rust ignore">    use std::fs;

    #[async_std::test]
    async fn test_handle_connection() {
        let input_bytes = b&quot;GET / HTTP/1.1\r\n&quot;;
        let mut contents = vec![0u8; 1024];
        contents[..input_bytes.len()].clone_from_slice(input_bytes);
        let mut stream = MockTcpStream {
            read_data: contents,
            write_data: Vec::new(),
        };

        handle_connection(&amp;mut stream).await;
        let mut buf = [0u8; 1024];
        stream.read(&amp;mut buf).await.unwrap();

        let expected_contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let expected_response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, expected_contents);
        assert!(stream.write_data.starts_with(expected_response.as_bytes()));
    }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
