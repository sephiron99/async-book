<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>러스트 비동기 프로그래밍</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_getting_started/01_chapter.html"><strong aria-hidden="true">1.</strong> 시작하며</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_getting_started/02_why_async.html"><strong aria-hidden="true">1.1.</strong> Async가 필요한 이유</a></li><li class="chapter-item expanded "><a href="01_getting_started/03_state_of_async_rust.html"><strong aria-hidden="true">1.2.</strong> 비동기적 러스트 현황</a></li><li class="chapter-item expanded "><a href="01_getting_started/04_async_await_primer.html"><strong aria-hidden="true">1.3.</strong> async/.await 기초</a></li></ol></li><li class="chapter-item expanded "><a href="02_execution/01_chapter.html"><strong aria-hidden="true">2.</strong> 내부 구조: Future와 task 실행하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_execution/02_future.html"><strong aria-hidden="true">2.1.</strong> Future 트레잇</a></li><li class="chapter-item expanded "><a href="02_execution/03_wakeups.html"><strong aria-hidden="true">2.2.</strong> Waker로 Task 깨우기</a></li><li class="chapter-item expanded "><a href="02_execution/04_executor.html"><strong aria-hidden="true">2.3.</strong> 응용: executor 구현하기</a></li><li class="chapter-item expanded "><a href="02_execution/05_io.html"><strong aria-hidden="true">2.4.</strong> Executor와 시스템 입출력</a></li></ol></li><li class="chapter-item expanded "><a href="03_async_await/01_chapter.html"><strong aria-hidden="true">3.</strong> async/await</a></li><li class="chapter-item expanded "><a href="04_pinning/01_chapter.html"><strong aria-hidden="true">4.</strong> Pinning</a></li><li class="chapter-item expanded "><a href="05_streams/01_chapter.html"><strong aria-hidden="true">5.</strong> Streams</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_streams/02_iteration_and_concurrency.html"><strong aria-hidden="true">5.1.</strong> Iteration and Concurrency</a></li></ol></li><li class="chapter-item expanded "><a href="06_multiple_futures/01_chapter.html"><strong aria-hidden="true">6.</strong> 여러개의 future를 동시에 실행하기</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_multiple_futures/02_join.html"><strong aria-hidden="true">6.1.</strong> join!</a></li><li class="chapter-item expanded "><a href="06_multiple_futures/03_select.html"><strong aria-hidden="true">6.2.</strong> select!</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.3.</strong> TODO: Spawning</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.4.</strong> TODO: Cancellation and Timeouts</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.5.</strong> TODO: FuturesUnordered</a></li></ol></li><li class="chapter-item expanded "><a href="07_workarounds/01_chapter.html"><strong aria-hidden="true">7.</strong> Workarounds to Know and Love</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_workarounds/02_err_in_async_blocks.html"><strong aria-hidden="true">7.1.</strong> ? in async Blocks</a></li><li class="chapter-item expanded "><a href="07_workarounds/03_send_approximation.html"><strong aria-hidden="true">7.2.</strong> Send Approximation</a></li><li class="chapter-item expanded "><a href="07_workarounds/04_recursion.html"><strong aria-hidden="true">7.3.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="07_workarounds/05_async_in_traits.html"><strong aria-hidden="true">7.4.</strong> async in Traits</a></li></ol></li><li class="chapter-item expanded "><a href="08_example/00_intro.html"><strong aria-hidden="true">8.</strong> Final Project: HTTP Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08_example/01_running_async_code.html"><strong aria-hidden="true">8.1.</strong> Running Asynchronous Code</a></li><li class="chapter-item expanded "><a href="08_example/02_handling_connections_concurrently.html"><strong aria-hidden="true">8.2.</strong> Handling Connections Concurrently</a></li><li class="chapter-item expanded "><a href="08_example/03_multithreading.html"><strong aria-hidden="true">8.3.</strong> Serving Requests in Parallel</a></li><li class="chapter-item expanded "><a href="08_example/04_tests.html"><strong aria-hidden="true">8.4.</strong> Testing the Server</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">9.</strong> TODO: I/O</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">9.1.</strong> TODO: AsyncRead and AsyncWrite</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">10.</strong> TODO: Asynchronous Design Patterns: Solutions and Suggestions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">10.1.</strong> TODO: Modeling Servers and the Request/Response Pattern</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">10.2.</strong> TODO: Managing Shared State</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">11.</strong> TODO: The Ecosystem: Tokio and More</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">11.1.</strong> TODO: Lots, lots more?...</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">러스트 비동기 프로그래밍</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/sephiron99/async-book/tree/ko_KR/ko" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#시작하며" id="시작하며">시작하며</a></h1>
<p>러스트로 비동기 프로그래밍하기에 오신 것을 환영합니다. 만약 비동기 러스트 코드를
배우려고 하셨다면, 제대로 찾아오셨습니다. 웹서버나 데이터베이스, 또는 운영체제를
만든다면, 이 책이 하드웨어 성능의 대부분을 뽑아낼 수 있는 러스트의 비동기
프로그래밍 방법를 알려드릴 것입니다.</p>
<h2><a class="header" href="#이-책이-다루는-것들" id="이-책이-다루는-것들">이 책이 다루는 것들</a></h2>
<p>이 책은 러스트의 비동기 기능과 라이브러리를 사용하기 위한 종합적이고 최신의
가이드를 초심자와 숙련자 모두에게 제공하고자 합니다. </p>
<ul>
<li>
<p>이 책의 초반에서는 일반적인 비동기 프로그래밍과 러스트만의 비동기 프로그래밍에 대해 소개합니다.</p>
</li>
<li>
<p>중반부에서는 비동기 코드를 작성할 때 사용되는 핵심 기능과 흐름제어 도구들에
대해 논의합니다. 그리고 라이브러리와 어플리케이션에 최고의 성능과 재사용성을
부여하기 위해 필요한 모범답안을 설명합니다.</p>
</li>
<li>
<p>종반부에서는 보다 넓은 비동기 생태계에 대해 설명하고, 업무에 보편적으로
사용되는 다양한 방법에 대한 예제를 제공합니다.</p>
</li>
</ul>
<p>자, 이제 흥미진진한 러스트의 비동기 프로그래밍 세계로 모험을 떠납니다!</p>
<h1><a class="header" href="#비동기화가-필요한-이유" id="비동기화가-필요한-이유">비동기화가 필요한 이유</a></h1>
<p>우리모두는 빠르고 안전한 소프트웨어를 작성할 수 있는 러스트를 좋아합니다. 하지만
왜 비동기 코드를 작성해야 할까요?</p>
<p>비동기 코드는 우리가 같은 운영체제 스레드 위에서 여러 task을 동시에 돌릴 수 있게 
해줍니다. 당신이 전형적인 스레드 앱에서 동시에 웹 페이지 두 장을 다운로드하고 
싶으면, 스레드 두 개를 통해 task을 넓힐 수 있습니다. 이렇게요.</p>
<pre><code class="language-rust ignore">fn get_two_sites() {
    // task에 사용될 두 개의 스레드 생성
    let thread_one = thread::spawn(|| download(&quot;https://www.foo.com&quot;));
    let thread_two = thread::spawn(|| download(&quot;https://www.bar.com&quot;));

    // 두 개의 스레드가 완료될 때까지 기다림
    thread_one.join().expect(&quot;thread one panicked&quot;);
    thread_two.join().expect(&quot;thread two panicked&quot;);
}
</code></pre>
<p>이 동작은 많은 앱에 잘 돌아갑니다. 결국 스레드는 한 번에 여러 task을 수행하기 
위해 만들어졌습니다. 하지만 이런 행위에는 한계가 있습니다. 서로 다른 스레드를 
바꾸거나 스레드끼리 데이터를 공유하는 과정에서 다소의 오버헤드가 발생하기 때문입니다. 
존재하지만 아무 것도 하지 않는 스레드가 귀중한 시스템 자원을 고갈시킬 수도 있습니다.
이러한 문제를 없애기 위해 비동기 코드가 만들어졌습니다. 우리는 러스트의 <code>async</code>/
<code>.await</code> 표기를 함으로써 함수를 다시 작성할 수 있고, 그 코드는 다수의 스레드를 만들지 
않고 한 번에 여러 task을 수행할 수 있게 만듭니다.</p>
<pre><code class="language-rust ignore">async fn get_two_sites_async() {
    // 완성될때까지 실행된다면, 웹페이지를 비동기적으로 다운로드 할 두 개의 다른
    // &quot;future&quot;를 만들기
    let future_one = download_async(&quot;https://www.foo.com&quot;);
    let future_two = download_async(&quot;https://www.bar.com&quot;);

    // 두 개의 future를 완성될때까지 동시에 실행하기
    join!(future_one, future_two);
}
</code></pre>
<p>대체로 비동기적인 앱은 똑같이 스레드로 구현된 방식보다 더 빠르고 더 자원을 덜 쓰는 
잠재력이 있습니다. 그러나 한계도 있습니다. 스레드는 본디 운영체제에서 지원하고, 
어떤 특별한 프로그래밍 모델도 필요하지 않습니다. 어떤 함수라도 스레드를 만들 수 
있으며, 스레드를 사용하는 함수를 부르는 것은 그렇지 않은 평범한 함수를 부르는 것처럼 
쉽습니다. 하지만 비동기 함수는 언어나 라이브러리로부터 특별한 지원을 받아야 합니다. 
러스트에서는 <code>async fn</code> 표기가 <code>Future</code>를 반환하는 비동기 함수를 만들 수 있습니다. 
함수를 실행하기 위해 반환된 <code>Future</code>는 완벽히 수행되어야 합니다.</p>
<p>전형적인 스레드 앱이 매우 효과적일 수도 있고 러스트가 차지하는 작은 메모리 공간과 예측 
가능성이 <code>async</code>를 멀리 할 수 있다는 것을 의미한다는 것을 기억하시기 바랍니다. 비동기 
프로그래밍 모델의 복잡성이 항상 옳은 것은 아니고 당신의 앱이 더 간단한 스레드 모델을 
사용하는 게 더 좋은 것인지 생각해야 합니다.</p>
<h1><a class="header" href="#비동기적-러스트-현황" id="비동기적-러스트-현황">비동기적 러스트 현황</a></h1>
<p>비동기적 러스트 생태계는 장시간에 걸쳐 많은 진화를 이루어냈기 떄문에, 어떤
도구를 사용해야 할지, 어떤 라이브러리에 투자할지, 또는 어떤 문서를 읽어야 할 지
판단하기 어려울 수도 있습니다. 하지만, 표준 라이브러리의 <code>Future</code> 트레잇과
<code>async</code>/<code>await</code> 언어 기능은 최근에 안정화되는 등, 비동기적 러스트 생태계는
전체적으로 새롭게 안정화된 API로 마이그레이션하는 과정의 한 가운데 있습니다. 이
과정이 지나면, 지금의 혼란은 눈에 띄게 줄어들 것입니다.</p>
<p>지금 시점에서는 비동기적 러스트 생태계가 활발히 개발중에 있기 때문에, 비동기적
러스트가 세련되지 않다고 느낄수 있습니다. 대부분의 라이브러리는 아직도 <code>futures</code>
크레잇의 버전 0.1 정의를 사용하고 있어, 개발자들이 호환성을 위해 <code>futures</code>
크레잇 버전 0.3의 <code>compat</code> 기능을 자주 이용해야 합니다. 그리고 <code>async</code> / <code>await</code>
언어 기능은 아직 생소합니다. 게다가 중요한 확장기능이라 할만한 트레잇 메소드
안에서의 <code>async fn</code> 문법이 아직 구현되지 않았고, 현재의 컴파일러 에러 메시지는
분석하기 어렵습니다.</p>
<p>그렇긴 하지만, 러스트는 비동기적 프로그래밍에 대한 가장 빠르고 프로그래머
친화적인 지원체계를 갖추기 위해 노력하고 있습니다. 모험을 두려워하지 않는
분이라면 비동기적 러스트 프로그래밍의 세계에 도전하세요!</p>
<h1><a class="header" href="#asyncawait-기초" id="asyncawait-기초"><code>async</code>/<code>.await</code> 기초</a></h1>
<p><code>async</code>/<code>.await</code>는 동기적 코드처럼 보이는 비동기 함수들을 작성하는 데 쓰이는
러스트안에 내장된 도구입니다. <code>async</code>는 코드 블록을 <code>Future</code>라는 트레잇을
구현하는 유한상태기계로 변환해줍니다. 동기적 메소드 안에서 블록하는 함수를
호출한다면 전체 스레드가 블록되지만, 블록된 <code>Future</code>는 스레드를 잡아놓지
않아 다른 <code>Future</code>도 동작할 수 있습니다.</p>
<p><code>Cargo.toml</code> 파일에 의존성을 추가해 봅시다.</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
</code></pre>
<p>비동기 함수를 만들기 위해, <code>async fn</code> 문법을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn do_something() { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p><code>async fn</code>이 반환하는 값은 한 개의 <code>Future</code> 객체입니다. 코드가 실제로 동작하게
하려면, <code>Future</code> 객체가 executor에 의해 실행되어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// `block_on` blocks the current thread until the provided future has run to
// completion. Other executors provide more complex behavior, like scheduling
// multiple futures onto the same thread.
use futures::executor::block_on;

async fn hello_world() {
    println!(&quot;hello, world!&quot;);
}

fn main() {
    let future = hello_world(); // Nothing is printed
    block_on(future); // `future` is run and &quot;hello, world!&quot; is printed
}
</code></pre></pre>
<p><code>async fn</code> 안에서는 <code>Future</code> 트레잇을 구현한 다른 타입이 완성될 때(예를 들어
다른 <code>async fn</code>의 출력같은 것)까지 기다리기 위해 <code>.await</code>을 사용합니다. <code>block on</code>과 달리, <code>.await</code>는 현재의 스레드를 블럭하지 않고, 대신에 다른 task들이
수행될수 있게 허용하면서도 그 future가 완성될 때까지 비동기적으로 기다립니다.</p>
<p>예를 들어, <code>async fn</code>으로 확장된 <code>learn_song</code>, <code>sing_song</code>, <code>dance</code> 가 있다고
칩시다.</p>
<pre><code class="language-rust ignore">async fn learn_song() -&gt; Song { /* ... */ }
async fn sing_song(song: Song) { /* ... */ }
async fn dance() { /* ... */ }
</code></pre>
<p>노래를 배우고 부르며, 춤을 추기위한 방법 중에 하나는 각각을 수행할 때마다
블록하는 것입니다.</p>
<pre><code class="language-rust ignore">fn main() {
    let song = block_on(learn_song());
    block_on(sing_song(song));
    block_on(dance());
}
</code></pre>
<p>그러나, 이 방법으로는 최선의 성능을 낼 수 없습니다. 오직 한 번에 한 가지만
한다구요!. 우리가 노래를 부르기 전에 배워야만 하는 것은 명백하지만, 춤은 노래를
배우고 부르면서도 출 수 있습니다. 이를 위해, 이를 위해, 우리는 동시에 수행될 수
있는 두 개의 다른 <code>async fn</code>을 만들면 됩니다.</p>
<pre><code class="language-rust ignore">async fn learn_and_sing() {
    // Wait until the song has been learned before singing it.
    // We use `.await` here rather than `block_on` to prevent blocking the
    // thread, which makes it possible to `dance` at the same time.
    let song = learn_song().await;
    sing_song(song).await;
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    // `join!` is like `.await` but can wait for multiple futures concurrently.
    // If we're temporarily blocked in the `learn_and_sing` future, the `dance`
    // future will take over the current thread. If `dance` becomes blocked,
    // `learn_and_sing` can take back over. If both futures are blocked, then
    // `async_main` is blocked and will yield to the executor.
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}
</code></pre>
<p>이 예제에서, 노래 배우기는 노래 부르기보다 먼저 동작해야 하지만, 노래 배우기와
부르기는 춤추기와 같은 시간에 동작할 수 있습니다. 만약 <code>learn_and_sing</code>안에서
<code>learn_song().await</code>말고, <code>block_on(learn_song())</code>을 사용했다면, 해당
스레드는 <code>learn_song</code>이 동작하는 동안에는 아무것도 할 수 없었을 것이고. 그렇다면
춤추기를 노래와 동시에 수행할 수 없었을 것입니다. 하지만 우리는 <code>learn_song</code>
future를 <code>.await</code>함으로써, <code>learn_song</code>이 블럭되었을지라도 다른 task들이 현재의
스래드에서 실행되게 할 수 있습니다. 이 방법으로, 여러개의 future를 한 개의
스레드에서 동시에 실행하여 완성할 수 있습니다.</p>
<h1><a class="header" href="#내부-구조-future와-task-실행하기" id="내부-구조-future와-task-실행하기">내부 구조: <code>Future</code>와 task 실행하기</a></h1>
<p>이 장에서는, <code>Future</code>와 비동기 task들을 스케쥴링하는 세부적인 구조에 대해 다룰
것입니다.  만약 <code>Future</code>를 단순히 사용하는 방법에만 관심이 있고, <code>Future</code>가
작동하는 세부 원리에 대해서는 관심이 없다면, <code>async</code> / <code>await</code> 장으로 건너뛰셔도
됩니다. 하지만, 이 장에서 다루는 여러 내용들은 <code>async</code> / <code>await</code>의 작동방식을
이해하고, <code>async</code> / <code>await</code> 코드의 런타임과 성능요인을 이해하며, 새로운 비동기
primitive을 만드는 데 도움이될 것입니다. 만약, 이 장을 건너뛰기로 하셨다면,
나중에라도 읽기 위해 북마크해놓으실 것을 추천합니다.</p>
<p>자, 이제 본격적으로 <code>Future</code>에 대해 알아봅시다.</p>
<h1><a class="header" href="#future-트레잇" id="future-트레잇"><code>Future</code> 트레잇</a></h1>
<p><code>Future</code> 트레잇은 러스트 비동기 프로그래밍의 핵심입니다. <code>Future</code>는 비동기
연산의 일종으로, 한 개의 값을 산출할 수 있습니다(그 값이 <code>()</code>같은 빈
값일지라도요). <em>단순화된</em> 버전의 future 트레잇은 다음과 같은 형태라고 할 수
있습니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SimpleFuture {
    type Output;
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>Future는 'poll' 함수를 호출하면 진행됩니다. <code>poll</code> 함수는 future가 완성될때까지
가능한만큼만 진행시킬 것입니다. 만약 Future가 완성된다면, Future는
<code>Poll::Ready(result)</code>를 반환합니다. Future가 아직 완성될 수 없다면, Future는
<code>Poll::Pending</code>을 반환한고, <code>Future</code>가 좀더 진행될 때를 대비하여 <code>wake()</code>함수를
준비합니다. <code>wake()</code> 함수가 호출되었을 때, <code>Future</code>를 운전(drive)하는
executor는 <code>poll</code>을 다시 호출하여 <code>Future</code>가 더 진행될 수 있게 합니다.</p>
<p><code>wake()</code> 없다면, executor는 어떤 future가 진행할 준비가 되었는지를 알 방법이
없어서, 아마 끊임없이 모든 future를 폴링(polling)해야만 할 것입니다. <code>wake()</code>
덕분에, executor는 어떤 future가 <code>poll</code> 될 수 있는지 정확히 알 수 있습니다.</p>
<p>예를 들어, 데이터를 제공할 준비가 되어 있는지 아닌지 알 수 없는 소켓에서
데이터를 읽어야 하는 사례를 생각해봅시다. 만약 데이터가 있다면, 우리는 데이터를
읽어들여서 <code>Poll::Ready(data)</code>를 반환하면 됩니다. 하지만, 데이터가 없다면,
future는 블록될 것이고, 더 이상 진행할 수 없을 것입니다. 데이터가 준비되지
않았을 때에는, 데이터가 소켓에 준비되었을 때 <code>wake</code>가 호출될 수 있도록 <code>wake</code>를
등록해야 합니다. 이렇게 등록하면 executor에게 우리의 future가 진행될 준비가
되었음을 알릴 수 있습니다. 간단한 <code>SocketRead</code> future는 다음과 같은 형태라고 할
수 있습니다.</p>
<pre><code class="language-rust ignore">pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // 소켓에 데이터가 준비됨-- 버퍼에 읽어 들이고 버퍼를 반환
            Poll::Ready(self.socket.read_buf())
        } else {
            // 소켓에 아직 데이터가 준비되지 않음
            //
            // 데이터가 확보될 때, `wake`가 호출될 수 있도록 준비함.
            // 데이터가 확보되면, `wake`가 호출되고, 이 `Future`의 사용자는
            // `poll`을 다시 호출하여 데이터를 읽을 수 있음을 알게 된다.
            // (TODO: 읽을 수 있음을 -&gt; 읽음을?)
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p>아래 <code>Future</code> 모델은 여러개의 비동기 실행을 중간에 할당 없이 서로를 구성할 수
있게 해줍니다. 여러개의 future를 한 번에 실행하거나 각각을 연결하는 것은 다음과
같이 할당 없는 상태기계로 구현될 수 있습니다.</p>
<pre><code class="language-rust ignore">/// 두 개의 다른 future를 실행하여 동시에 완성하는 SimpleFuture.
///
/// 각각의 future에 대한 `poll` 함수의 호출이 교차배치될 수 있어, 각 future가
/// 각자의 페이스대로 진행될 수 있게 해준다. 이를 통해 동시성을 얻을 수 있다.
pub struct Join&lt;FutureA, FutureB&gt; {
    // 각 필드는 완성될 때까지 실행되어야 하는 future를 한 개씩 갖을 수 있다.
    // 만약, future가 이미 완성되었다면, 그 필드는 `None`으로 설정된다.
    // 이를 통해, future가 완성된 이후에 폴링하는 `Future` trait 규칙 위반을
    // 예방할 수 있다.
    a: Option&lt;FutureA&gt;,
    b: Option&lt;FutureB&gt;,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for Join&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        // future `a`를 완성하려고 시도함.
        if let Some(a) = &amp;mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // future `b`를 완성하려고 시도함.
        if let Some(b) = &amp;mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() &amp;&amp; self.b.is_none() {
            // 두 future 모두 완성되었음-- 성공적으로 반환함
            Poll::Ready(())
        } else {
            // 하나 또는 두 개의 future가 `Poll::Pending`을 반환하므로, 아직
            // 해야 할 task이 남아 있습니다. future(들)은 진행이 가능 할 때
            // `wake()`를 호출할 것입니다.
            Poll::Pending
        }
    }
}
</code></pre>
<p>위 예제는 여러개의 future가 각각에 대한 할당 없이도 어떻게 동시에 실행 될 수 있는지
보여줍니다. 이는 보다 효율적인 비동기 프로그램입니다. 마찬가지로, 여러개의 순차적
future는 아래와 같이 한 개 한 개 씩 실행될 수 있습니다.</p>
<pre><code class="language-rust ignore">/// 두 개의 future가 완성될 때까지 순차적으로 실행하는 SimpleFuture
//
// 주의: 이 간단한 예제의 목적에 맞도록, `AndThenFut`은 첫 번째와 두 번째
// future 둘 다 생성시에 활성화되었다고 가정합니다. 진짜 `AndThen` 조합자는
// `get_breakfast.and_then(|food| eat(food))`와 같은 식으로 첫 번째 future의
// 결과에 따라 두 번째 future를 만들 수 있습니다.
pub struct AndThenFut&lt;FutureA, FutureB&gt; {
    first: Option&lt;FutureA&gt;,
    second: FutureB,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for AndThenFut&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if let Some(first) = &amp;mut self.first {
            match first.poll(wake) {
                // 첫 번째 future가 완성되었습니다. 첫 번째를 제거하고 두 번째를
                // 시작합니다!
                Poll::Ready(()) =&gt; self.first.take(),
                // 첫 번째 future도 완성되지 못했습니다.
                Poll::Pending =&gt; return Poll::Pending,
            };
        }
        // 이제 첫 번재 future가 완성되었으니, 두 번째 future를 완성하려고
        // 시도합니다.
        self.second.poll(wake)
    }
}
</code></pre>
<p>위의 예제들은 <code>Future</code> 트레잇이 여러개의 할당된 객체나 반복중첩된(deeply nested)
콜백 없이 비동기 흐름 제어를 구현하는 방법을 보여줍니다. 기본적인 흐름제어에
대한 설명은 이쯤에서 마치고, 진짜 <code>Future</code> 트레잇은 어떻게 생겼고, 무엇이 다른지
살펴봅시다.</p>
<pre><code class="language-rust ignore">trait Future {
    type Output;
    fn poll(
        // `&amp;mut self`에서 `Pin&lt;&amp;mut Self&gt;`로 변화되었음:
        self: Pin&lt;&amp;mut Self&gt;,
        // `wake: fn()`에서 `cx: &amp;mut Context&lt;'_&gt;`로 변화되었음:
        cx: &amp;mut Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre>
<p>여러분이 확인하게 된 첫 번째 변화는 <code>self</code> 타입이 더 이상 <code>&amp;mut Self</code>가 아니고,
<code>Pin&lt;&amp;mut Self&gt;</code>로 바뀌었다는 점입니다. <a href="02_execution/../04_pinning/01_chapter.html">a later section</a>에서 pinning에
대해 더 다루겠지만, 지금은 이동불가한 future를 만들 수 있게 해준다는 점을 알아
두십시오. 이동불가한 객체는 <code>struct MyFut { a: i32, ptr_to_a: *const i32 }</code> 처럼
필드 사이에 포인터를 저장할 수 있습니다. pinning은 async와 await를 활성화하기
위해 필요합니다.</p>
<p>두 번째로, <code>wake: fn()</code>은 <code>&amp;mut Context&lt;'_&gt;</code>으로 바뀌었습니다.
<code>SimpleFuture</code>에서, 우리는 future executor에게 완성되었는지 불확실한 future가
poll되어야 한다고 알려주기 위해 함수포인터 (<code>fn()</code>)에 대한 호출을
사용하였습니다. 하지만, <code>fn()</code>은 단지 함수포인터일 뿐, <em>어떤</em> <code>Future</code>가
<code>wake</code>를 호출했는지에 대한 정보를 저장할 수 없습니다.</p>
<p>웹 서버 같은 현실적인 시나리오의 복잡한 어플리케이션에는 각각의 wakeup이
개별적으로 관리되어야 하는 수 천개의 커넥션이 있을 겁니다. 특정한 task를
wake하기 위해 사용되는 <code>Waker</code> 타입의 값에 대한 접근을 제공하는 <code>Context</code> 타입을
이용하여 이를 해결합니다.</p>
<h1><a class="header" href="#waker로-task-깨우기" id="waker로-task-깨우기"><code>Waker</code>로 Task 깨우기</a></h1>
<p>future들이 첫 번째 <code>poll</code>에서는 완성되지 못하는 것이 일반적입니다. 완성되지
못했을 경우, 더 진행이 가능할 준비가 되었을 때, future가 poll될 수 있게 확실히
조치해둘 필요가 있습니다. <code>Waker</code> 타입으로 이 조치를 취할 수 있습니다.</p>
<p>future가 poll될 때마다 한 &quot;task&quot;의 일부분으로서 poll됩니다. task들이란 한 executor에게
제공된 최상위 future들입니다.</p>
<p><code>Waker</code>는 executor에게 연관된 task가 깨워져야 한다고 알리는데 사용되는 <code>wake()</code>
메소드를 제공합니다. <code>wake()</code>가 호출되었을 때, executor는 <code>Waker</code>와 연관된
task가 진행될 준비가 되었으며, task의 future가 다시 poll되어야 한다는 것을 알 수 있습니다.</p>
<p><code>Waker</code>는 <code>clone()</code>도 구현하기 때문에, 필요한 곳에 복사되고 저장될 수 있습니다.</p>
<p><code>Waker</code>를 사용하여 간단한 타이머를 구현해 봅시다.</p>
<h2><a class="header" href="#응용-타이머-만들기" id="응용-타이머-만들기">응용: 타이머 만들기</a></h2>
<p>이 예제의 목적에 따라, 우리는 타이머가 만들어졌을 때 그냥 새 스레드를 하나
생성할 것이고, 필요한 만큼 sleep할 것입니다. 그리고 time window가 지나면,
타이머 future에 시그널을 보낼 것입니다.</p>
<p>시작하려면 다음처럼 import해야할 것들이 있습니다.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
<span class="boring">}
</span></code></pre></pre>
<p>시작은 future 타입 자체를 정의하는 것입니다. 우리의 future는 타이머가
경과되었는지, 그래서 future가 완성되어야 하는지 여부를 스레드가 알 수 있는
방법이 필요합니다. 그래서 공유된 <code>Arc&lt;Mutex&lt;..&gt;&gt;</code> 값을 사용해서 스레드와 future
사이에 통신할 것입니다.</p>
<pre><code class="language-rust ignore">pub struct TimerFuture {
    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,
}

/// future와 대기중인 스레드 사이에 공유된 상태
struct SharedState {
    /// 타이머가 경과되었는 지 여부
    completed: bool,

    /// `TimerFuture`가 실행될 태스크 용 waker.
    /// 스레드는 `completed = true`라고 설정한 후에 `TimerFuture`의 task에게
    /// '일어나서 `completed = true`인지 확인하고 진행하라'고 전하는 데 이
    /// waker를 사용할 수 있다.
    waker: Option&lt;Waker&gt;,
}
</code></pre>
<p>자, 진짜로 <code>Future</code> 구현을 작성해 봅시다.</p>
<pre><code class="language-rust ignore">impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        // 타이머가 이미 완성되었는지 알기 위해 공유된 상태를 확인.
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // waker를 설정해서 타이머가 완성되었을 때 스레드가 현재의 task를
            // 깨울 수 있게 한다. 이렇게 함으로써 future가 다시 poll되어
            // `completed = true`가 맞는지 확인 할 수 있다.
            //
            // waker를 매번 반복적으로 클론하지 않고 한 번만 클론하고 싶을 수도
            // 있다. 하지만, `TimerFuture`는 executor의 여러 task들로 이동할 수
            // 있기 때문에, 한 번만 클론하면 잘못된 task를 가리키는 정체된
            // waker가 만들어져 `TimerFuture`가 제대로 못 깨워질 것이다.
            //
            // 주의: `Waker::will_wake` 함수를 이용하여 `TimerFuture`가
            // 제대로 못 깨워지는 문제를 체크할 수 있으나, 예제를 간단하게 
            // 하기 위해 생략하였다.
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}
</code></pre>
<p>꽤 간단하죠? 스레드가 <code>shared_state.completed = true</code>로 설정하였다면 다 된
것입니다. 아니라면, 우리는 스레드가 task를 다시 깨울 수 있도록, <code>Waker</code>를 현재의
task용으로 클론하여 <code>shared_state.waker</code>에 전달합니다.</p>
<p>중요한 점은, <code>Waker</code>를 future가 poll될 때마다 갱신해야 한다는 점입니다.
왜냐하면, 그 future가 다른 <code>Waker</code>와 같이 다른 task로 이동했을 수 있기
때문입니다. 이런 상황은 future가 poll되고 나서 task 사이에서 여기저기 전달될 때
발생합니다. </p>
<p>마지막으로, 실제로 타이머를 만들고 스레드를 시작할 API가 필요합니다.</p>
<pre><code class="language-rust ignore">impl TimerFuture {
    /// 주어진 시간이 경과하면 완성되는 새로운 `TimerFuture`를 만든다.
    pub fn new(duration: Duration) -&gt; Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // 새로운 스레드 생성
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // 타이머가 완성되어서 future가 poll된 마지막 task를 (존재한다면)
            // 깨우는 시그널
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
</code></pre>
<p>짠! 이게 간단한 타이머 future를 만드는데 필요한 전부입니다. 이제 future가 실행될
executor만 있으면 되는데요...</p>
<h1><a class="header" href="#응용-executor-구현하기" id="응용-executor-구현하기">응용: executor 구현하기</a></h1>
<p>러스트 <code>Future</code>는 지연계산됩니다. 실제로 완성시키기 위해 운전(TODO: 실행?)하기
전까지 future는 아무것도 하지 않을 것입니다. future를 완성시키기 위해 운전하는
한 가지 방법은 <code>async</code> 함수 안에서 future를 <code>.await</code>하는 것입니다. 다만, 그렇게
하면 문제가 하나 생깁니다: 누가 최상위 <code>async</code> 함수로부터 반환된 future를 실행할
것인가라는 문제입니다. 그리고 그 해답은 <code>Future</code> executor입니다.</p>
<p><code>Future</code> executor는 최상위 <code>Future</code>의 집합을 받아 <code>Future</code>가 진행할 수 있을
때마다 <code>poll</code>을 호출해서 완성될 때까지 실행합니다. 일반적으로, executor는
시작하면서 future를 한 번 <code>poll</code>합니다. <code>Future</code>가 <code>wake()</code>를 호출하여 진행할
준비가 되었음을 알릴 때, future는 큐 뒤에 넣어지고, <code>poll</code>이 다시 호출됩니다.
이는 <code>Future</code>가 완성될 때까지 반복됩니다.</p>
<p>이 장에서 우리는 수많은 최상위 future를 완성될 때까지 동시에 실행할 수 있는
간단한 executor를 만들 것입니다.</p>
<p>이 예제에서 <code>Waker</code>를 쉽게 만들 수 있게 도와주는 <code>ArcWake</code> 트레잇 때문에
<code>futures</code> 크레잇 의존성이 필요합니다.</p>
<pre><code class="language-toml">[package]
name = &quot;xyz&quot;
version = &quot;0.1.0&quot;
authors = [&quot;XYZ Author&quot;]
edition = &quot;2018&quot;

[dependencies]
futures = &quot;0.3&quot;
</code></pre>
<p>다음은, <code>src/main.rs</code>의 맨 위에 아래와 같이 import합니다.</p>
<pre><code class="language-rust ignore">use {
    futures::{
        future::{BoxFuture, FutureExt},
        task::{waker_ref, ArcWake},
    },
    std::{
        future::Future,
        sync::mpsc::{sync_channel, Receiver, SyncSender},
        sync::{Arc, Mutex},
        task::{Context, Poll},
        time::Duration,
    },
    // 이전 장에서 작성한 타이머
    timer_future::TimerFuture,
};
</code></pre>
<p>실행할 task를 채널을 통해 보내면 우리의 executor가 작동할 겁니다. executor는
채널에서 이벤트를 당겨와서 실행합니다. 만약, 어떤 task가 조금 더 일 할 준비가
됐다면(즉, 깨워진다면), 그 task는 자기가 다시 poll될 수 있게 채널에 자기
스스로를 넣습니다.</p>
<p>이러한 설계 덕분에, executor는 그저 task 채널의 수신 단말만 있으면 됩니다.
유저에게는 송신 단말이 주어지므로, 새로은 future를 만들 수 있습니다. Task라는
것은 결국 스스로를 다시 스케쥴링할 수 있는 future일 뿐입니다. 따라서, 우리는
task들을 송신자(sender)와 짝지운 future의 형태로 저장할 것입니다. 송신자는
task가 자기자신을 큐에 넣는데 사용됩니다.</p>
<pre><code class="language-rust ignore">/// 채널에서 task를 받아서 실행하는 task executor
struct Executor {
    ready_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
}

/// 새 future를 task 채널에 생성해 넣는 `Spawner`
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

/// `Executor`에게 poll될 수 있게 스스로를 재스케줄링하는 future
struct Task {
    /// 완성되기 위해서 큐에 넣어져야 하는, 진행중인 future
    ///
    /// 정확히 하자면, `Mutex`가 꼭 필요한 것은 아니다. 우리는 한 시점에
    /// (future들을 실행하는) 오직 하나의 스레드만 가지고 있기 때문이다. 하지만,
    /// 러스트는 우리의 `future`가 한 개의 스레드 안에서만 변경된다는 사실을 알
    /// 수 없기 때문에, 우리는 스레드 안전성을 위해 `Mutex`를 사용해야만 한다.
    /// 현업에서는 `Mutex` 대신 `UnsafeCell`을 사용할 수도 있다.
    future: Mutex&lt;Option&lt;BoxFuture&lt;'static, ()&gt;&gt;&gt;,

    /// task가 자기자신을 task 큐의 마지막에 넣는데 사용되는 핸들
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

fn new_executor_and_spawner() -&gt; (Executor, Spawner) {
    // 채널(큐)이 일시점에 가질 수 있는 task의 최대 갯수.
    // 그냥 `sync_channel`을 만드는데 필요한 것이고, 실제 executor에 적용될 일은
    // 없을 것이다.
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}
</code></pre>
<p>새 future를 만들기 쉽게 메소드 한 개를 더 spawner에 추가합시다. 이 메소드는
future 타입을 받아서, box로 감싸고, 새 <code>Arc&lt;Task&gt;</code>로 만들 것입니다.
새로 만든 <code>Arch&lt;Task&gt;</code>는 excutor에게 enqueue될 것입니다.</p>
<pre><code class="language-rust ignore">impl Spawner {
    fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect(&quot;too many tasks queued&quot;);
    }
}
</code></pre>
<p>future를 poll하기 위해서는, <code>Waker</code>를 생성해야 합니다. <a href="02_execution/./03_wakeups.html">task 깨우기 section</a>에서
설명했듯이, <code>Waker</code>는 <code>wake</code>가 호출되면 task가 다시 poll될 수 있도록
스케쥴링합니다. <code>Waker</code>들은 executor에게 정확히 어떤 task가 준비되었는지
알려주기 때문에, executor는 진행할 준비가 된 future들만 poll한다는 점을
기억하십시오. 새로운 <code>Waker</code>를 만드는 가장 쉬운 방법은 <code>ArcWake</code> 트레잇을
구현하고, <code>waker_ref</code>나 <code>.into_waker()</code> 함수를 이용하여 <code>Arc&lt;impl ArcWake&gt;</code>를
<code>Waker</code>로 변경하는 것입니다. 우리의 task를 위한 <code>ArcWake</code>를 구현하여 <code>Waker</code>로
변경하고 깨워봅시다.</p>
<pre><code class="language-rust ignore">impl ArcWake for Task {
    fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
        // `wake`를 이 task를 다시 task 채널에 보내는 방식으로 구현한다. 그래서
        // executor가 이 task를 다시 poll할 것이다.
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect(&quot;too many tasks queued&quot;);
    }
}
</code></pre>
<p><code>Arc&lt;Task&gt;</code>로부터 만들어진 <code>Waker</code>의 <code>wake()</code>를 호출하면 <code>Arc</code>의 복사본이 task
채널로 송신될 것이다. 그러면 우리의 executor는 그 task를 집어 poll해야 한다.
구현해 봅시다.</p>
<pre><code class="language-rust ignore">impl Executor {
    fn run(&amp;self) {
        while let Ok(task) = self.ready_queue.recv() {
            // future를 취하고 나서, 아직 future가 완성되지 않았으면(아직 Some이면),
            // future를 완성하기 위해 poll한다.
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // task 자기자신으로부터 `LocalWaker`를 생성한다.
                let waker = waker_ref(&amp;task);
                let context = &amp;mut Context::from_waker(&amp;*waker);
                // `BoxFuture&lt;T&gt;`는 `Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send +
                // 'static&gt;&gt;`의 type alias이다.
                // `Pin::as_mut` 메소드를 호출하여 `BoxFuture&lt;T&gt;`로부터
                // `Pin&lt;&amp;mut dyn Future + Send + 'static&gt;`을 얻을 수 있다.
                if let Poll::Pending = future.as_mut().poll(context) {
                    // future의 처리가 끝나지 않았으므로, 그것의 task에 도로
                    // 넣어서 미래에 다시 실행될 수 있게 한다.
                    *future_slot = Some(future);
                }
            }
        }
    }
}
</code></pre>
<p>축하합니다! future executor를 완성하였습니다. 여러분이 만든 executor를
<code>asycn/.await</code> 코드나 우리가 아까 만든 <code>TimeFuture</code>같은 커스텀 future를
실행하는데도 사용할 수 있습니다.</p>
<pre><code class="language-rust edition2018 ignore">fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    // 타이머 전후로 문자열을 출력할 태스크를 생성한다.
    spawner.spawn(async {
        println!(&quot;howdy!&quot;);
        // 우리의 타이머 future가 2초 후에 완성될 때까지 기다린다.
        TimerFuture::new(Duration::new(2, 0)).await;
        println!(&quot;done!&quot;);
    });

    // 여러분의 executor가 spawner가 끝났음을 확인하고 더 이상 실행할 task를
    // 받지 않도록 spawner를 drop한다.
    drop(spawner);

    // excutor를 task 큐가 빌 때까지 실행한다. &quot;howdy!&quot; 출력, 일시중지,
    // &quot;done!&quot;출력 순으로 동작할 것이다.
    executor.run();
}
</code></pre>
<h1><a class="header" href="#executor와-시스템-입출력" id="executor와-시스템-입출력">Executor와 시스템 입출력</a></h1>
<p>우리는 이전 <a href="02_execution/./02_future.html"><code>Future</code> 트레잇</a> 장에서 소켓을 비동기적으로 읽는 아래의 future
예제에 대해 살펴보았습니다..</p>
<pre><code class="language-rust ignore">pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // 소켓에 데이터가 준비됨-- 버퍼에 읽어 들이고 버퍼를 반환
            Poll::Ready(self.socket.read_buf())
        } else {
            // 소켓에 아직 데이터가 준비되지 않음
            //
            // 데이터가 확보될 때, `wake`가 호출될 수 있도록 준비함.
            // 데이터가 확보되면, `wake`가 호출되고, 이 `Future`의 사용자는
            // `poll`을 다시 호출하여 데이터를 읽을 수 있음을 알게 된다.
            // (TODO: 읽을 수 있음을 -&gt; 읽음을?)
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p>이 future는 소켓에 준비된 데이터를 읽어들이지만, 준비된 데이터가 없다면
executor에게 &quot;소켓에 데이터가 준비되면 future의 task를 다시 깨워주세요&quot;라고
요청하면서 콘텍스트를 양보할 것입니다. 하지만, 이 예제에서는 <code>Socket</code> 타입이
어떻게 구현되는지 확실하지 않고, 특별히 <code>set_readable_callback</code> 함수가
작동하는지가 분명하지 않습니다. 어떻게 하면 소켓에 데이터가 준비되었을 때,
<code>wake()</code>가 호출될 수 있게 할까요? 끊임없이 <code>socket</code>이 준비되었는지 확인하여
맞으면 <code>wake()</code>를 호출하는 스레드를 하나 만드는 것도 선택지가 될 것입니다.
그러나 이 방법은 블록된 입출력 future 각각마다 별개의 스레드가 필요하기 때문에
매우 비효율적이어서 우리의 비동기 코드의 효율을 크게 저하시킬 것입니다.</p>
<p>사실 이 문제는 입출력과 연계된 시스템 블로킹 기본기능과 통합으로 해결합니다.
예를 들면 리눅스의 <code>epoll</code>, FreeBSD와 Mac OS의 <code>kqueue</code>, 윈도우즈의 IOCP,
퓨시아의 <code>port</code>같은 것들이 있습니다(그리고 이것들 모두는 크로스 플랫폼 려스트
크레잇인 <a href="https://github.com/tokio-rs/mio"><code>mio</code></a>를 이용하여 사용할 수 있습니다). 이러한 기본기능들은 모두 한
스레드가 여러개의 비동기 입출력 이벤트에 따라 블록하였다가 이벤트가 완성되면
반환할 수 있는 기능을 제공합니다. 이러한 API들은 실제로 보통 아래와 같은
형태입니다.</p>
<pre><code class="language-rust ignore">struct IoBlocker {
    /* ... */
}

struct Event {
    // 생성되어 전파되는 이벤트를 고유하게 식별하는 ID_
    id: usize,

    // 기다리고 있거나, 발생된 시그널 집합
    signals: Signals,
}

impl IoBlocker {
    /// 블록할 비동기 입출력 이벤트의 새로운 컬렉션을 만든다.
    fn new() -&gt; Self { /* ... */ }

    /// 특별한 입출력 이벤트에 interest를 삽입한다.
    fn add_io_event_interest(
        &amp;self,

        /// 이벤트가 발생할 오브젝트
        io_object: &amp;IoObject,

        /// TODO: 검토 필요
        /// `io_object`에서 나타날 시그널들의 집합이다. `io_object`에 대하여 
        /// 이벤트가 발동되어야 하는데, `io_object`는 ID와 짝지워져서 
        /// 이 interest에서 비롯된 이벤트들에게 주어진다. 
        event: Event,
    ) { /* ... */ }

    /// 이벤트 중에 하나가 발생할 때까지 블록한다.
    fn block(&amp;self) -&gt; Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &amp;socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &amp;socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// 소켓에 데이터가 준비되면 &quot;Socket 1 is now READABLE&quot; 같은 걸 출력한다.
println!(&quot;Socket {:?} is now {:?}&quot;, event.id, event.signals);
</code></pre>
<p>future의 executor들은 아래의 기본기능들을 비동기 입출력 객체를 제공하기 위해
사용할 수 있습니다. 예를 들어, 소켓은 특별한 입출력 이벤트가 발생하였을 때, 콜백이
실행되도록 설정할 수 있습니다. 위의 <code>SocketRead</code> 예제의 경우에
<code>Socket::set_readable_callback</code> 함수는 아래와 같은 의사코드와 비슷한 형태일
것입니다.</p>
<pre><code class="language-rust ignore">impl Socket {
    fn set_readable_callback(&amp;self, waker: Waker) {
        // `local_executor`는 지역 executor에 대한 레퍼런스이다.
        // `local_executor`는 소켓 생성시에 제공될 수도 있었겠지만, 실제로는 
        // 많은 executor 구현들이 편의상 스레드의 로컬 스토리지(TODO: 스레드 스택으로 
        // 의역?)를 통해서 아래로 전달한다. 
        let local_executor = self.local_executor;

        // 이 입출력 객체의 고유 ID
        let id = self.id;

        // executor의 맵에 지역 waker를 저장한다. 이를 통해 지역 waker는 입출력 이벤트가
        // 도착하면 호출될 수 있다.
        local_executor.event_map.insert(id, waker);
        local_executor.add_io_event_interest(
            &amp;self.socket_file_descriptor,
            Event { id, signals: READABLE },
        );
    }
}
</code></pre>
<p>이로써 우리는 어떤 입출력 이벤트라도 받아서 딱맞는 <code>Waker</code>에게 보내줄 수 있는
executor 스레드를 만들었습니다. 그리고 <code>Waker</code>는 이벤트에 대응하는 task를 깨울
것입니다. 또, executor는 입출력 이벤트를 더 확인하기 전에 보다 많은 task들을
완성까지 운전할 수 있을 것입니다(그리고 사이클은 반복됩니다...).</p>
<h1><a class="header" href="#asyncawait" id="asyncawait"><code>async</code>/<code>.await</code></a></h1>
<p>첫 장에서 우리는 <code>async</code>/<code>.await</code>을 짧게 다뤘습니다. 이제 <code>async</code> 코드가
어떻게 동작하고, 어떻게 전형적인 러스트 프로그램과 다른지 더 자세히 들여다봅시다.</p>
<p><code>async</code>/<code>.await</code>은 하나의 작업을 마칠 때 까지 기다리는 동안 다른 코드가 실행되는 것을 
막거나 허용하는 대신 현재 스레드의 제어를 내놓는 러스트 문법의 특별한 도구입니다.</p>
<p><code>async</code>를 다루는 주 방법 두 가지, <code>async fn</code>과 <code>async</code> 블록이 있습니다. 각각 <code>Future</code> 
트레잇을 구현한 값을 반환합니다.</p>
<pre><code class="language-rust edition2018 ignore">
// `foo()`는 `Future&lt;Output = u8&gt;`을 구현한 타입을 반환합니다.
// `foo().await`은 `u8` 타입의 값을 나타낼 것입니다.
async fn foo() -&gt; u8 { 5 }

fn bar() -&gt; impl Future&lt;Output = u8&gt; {
    // 이 `async` 블록은`Future&lt;Output = u8&gt;`을 구현한
    // 타입을 반환합니다.
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
</code></pre>
<p>첫 장에서 봤듯이, <code>async</code> 안쪽과 그 밖의 future 구현체는 게으릅니다. 즉 실행될 때까지 아무 
일도 안 합니다. <code>Future</code>를 실행하기 위해서는 <code>.await</code>을 써야 합니다. <code>Future</code> 상에서 
<code>.await</code>이 나오면 그 코드는 마칠 때까지 실행하려 할 것입니다. <code>Future</code>는 자신이 중지되면 
현재 스레드의 제어를 넘겨줍니다. 더 많은 흐름이 나올 시, <code>Future</code>는 <code>.await</code>을 풀고 실행자에게 
선택돼 실행을 재개할 것입니다.</p>
<h2><a class="header" href="#async한-수명" id="async한-수명"><code>async</code>한 수명</a></h2>
<p>참조나 기타 <code>'static</code>하지 않은 인자를 다루는 <code>async fn</code>은 전형적인 함수와 달리 인자의 수명으로 
정해지는 <code>Future</code>를 반환합니다.</p>
<pre><code class="language-rust edition2018 ignore">// 이 함수는
async fn foo(x: &amp;u8) -&gt; u8 { *x }

// 이 함수와 같습니다.
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}
</code></pre>
<p>즉 <code>'static</code>하지 않은 인자가 여전히 유효하는 한 <code>async fn</code>에서 나온 future는 <code>.await</code>해야 
합니다. 보통 <code>foo(&amp;x).await</code>와 같이 함수를 호출하고 바로 future를 <code>.await</code>할 때는 문제가 
없습니다. 허나 future를 또다른 작업이나 스레드로 저장하거나 보내면 문제가 생길 수 있습니다.</p>
<p>참조를 인자로 가진 <code>async fn</code>을 <code>'static</code>한 future로 바꾸는 방법 한 가지는 <code>async fn</code> 호출과 
인자값을 하나의 <code>async</code> 블록으로 묶는 것입니다.</p>
<pre><code class="language-rust edition2018 ignore">fn bad() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    borrow_x(&amp;x) // ERROR: `x`가 더 이상 쓸 수 없습니다.
}

fn good() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        borrow_x(&amp;x).await
    }
}
</code></pre>
<p>우리는 인자를 <code>async</code> 블록으로 옮김으로써 <code>good</code> 함수에서 나오는 <code>Future</code>의 것과 맞춰 인자의 
수명을 늘릴 수 있습니다.</p>
<h2><a class="header" href="#async-move" id="async-move"><code>async move</code></a></h2>
<p><code>async</code> 블록과 클로저는 보통 클로저처럼 <code>move</code> 키워드를 허용합니다. <code>async move</code> 블록은
자신이 참조하는 변수의 소유권을 현재 구역보다 더 오래 살리면서 다른 코드가 공유할 수 없도록 합니다.</p>
<pre><code class="language-rust edition2018 ignore">/// `async` 블록:
///
/// 여러 `async` 블록은 같은 지역 변수에 접근할 수 있고
/// 변수의 구역 안에서 실행될 수 있습니다.
async fn blocks() {
    let my_string = &quot;foo&quot;.to_string();

    let future_one = async {
        // ...
        println!(&quot;{}&quot;, my_string);
    };

    let future_two = async {
        // ...
        println!(&quot;{}&quot;, my_string);
    };

    // 두 future를 완전히 실행해 &quot;foo&quot;를 두 번 출력합니다:
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` 블록:
///
/// `async move` 블록으로부터 나온 `Future`가 캡처를 옮긴 이후로는 `async move` 
/// 블록 하나만 같은 캡처된 변수에 접근할 수 있습니다. 허나 이러면 `Future`를 원래 
/// 그 변수의 구역에서보다 오래 살게 합니다.
fn move_block() -&gt; impl Future&lt;Output = ()&gt; {
    let my_string = &quot;foo&quot;.to_string();
    async move {
        // ...
        println!(&quot;{}&quot;, my_string);
    }
}
</code></pre>
<h2><a class="header" href="#멀티스레드-실행자-상에서-await하기" id="멀티스레드-실행자-상에서-await하기">멀티스레드 실행자 상에서 <code>.await</code>하기</a></h2>
<p><code>Future</code>는 멀티스레드 상에서 <code>Future</code> 실행자를 사용할 때, <code>async</code> 안쪽에 쓰인 어떤 
변수라도 스레드 사이를 넘나들 수 있어야 하기 위해 어떤 <code>.await</code>이라도 잠재적으로 새로운 
스레드로 갈아탈 수 있듯이 스레드 사이를 건널 수도 있습니다.</p>
<p>그 말인 즉슨 <code>Sync</code> 트레잇을 구현하지 않은 타입에 대한 참조를 비롯해 <code>Send</code> 트레잇을 
구현하지 않은 <code>Rc</code>, <code>&amp;RefCell</code> 등 어떠한 타입도 안전하지 않습니다.</p>
<p>(알림: <code>.await</code>으로 호출하는 동안 구역 안에 있으면 이 타입들을 사용할 수 있습니다.)</p>
<p>요컨데 <code>.await</code>을 넘어서 future가 인식할 수 없는 전형적인 락을 다루는 것은 좋은 생각이 
아닙니다. 하나가 락을 차지하고, <code>.await</code>하면서 실행자에게 내놓는다면 또다른 작업이 락을 차지하려 
해 데드락이 발생하기 때문입니다. 이런 문제를 피하기 위해 <code>std::sync</code> 대신 <code>futures::lock</code>에 
있는 <code>Mutex</code>를 사용하시기 바랍니다.</p>
<h1><a class="header" href="#고정하기pinning" id="고정하기pinning">고정하기(Pinning)</a></h1>
<p>future를 poll하기 위해서는, future가 <code>Pin&lt;T&gt;</code>라는 특별한 타입으로 고정되어
있어야 합니다. 이전 <a href="04_pinning/../02_execution/01_chapter.html">&quot;<code>Future</code>와 task 실행하기&quot;</a> 장의 <a href="04_pinning/../02_execution/02_future.html"><code>Future</code> 트레잇</a>을
읽었다면, <code>Future::poll</code> 메소드의 정의에서 <code>self Pin&lt;&amp;mut Self&gt;</code>에 쓰였던
<code>Pin</code>을 보았을 것입니다. 그렇다면 <code>Pin</code>은 무슨 의미이고, 왜 필요할까요?</p>
<h2><a class="header" href="#왜-고정해야-하나요" id="왜-고정해야-하나요">왜 고정해야 하나요</a></h2>
<p><code>Pin</code>은 <code>Unpin</code> 마커와 쌍으로 작동합니다. 고정하기는 <code>!Unpin</code>을 구현하는 객체가
절대 움직이지 않음을 보장하여 줍니다. 이게 왜 필요한지 이해하려면, <code>async</code> /
<code>.await</code>가 작동하는 방식을 떠올려 보세요. 아래 코드를 살펴봅시다.</p>
<pre><code class="language-rust edition2018 ignore">let fut_one = /* ... */;
let fut_two = /* ... */;
async move {
    fut_one.await;
    fut_two.await;
}
</code></pre>
<p>보이지는 않지만, 위 코드는 <code>Future</code>를 구현하는 익명 타입을 만들어, 아래와 같은
<code>poll</code> 메소드를 제공합니다.</p>
<pre><code class="language-rust ignore">// 위 `async { ... }` 블록이 생성한 `Future` 타입
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// 위 `async`블록이 될 수 있는 상태의 종류
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        loop {
            match self.state {
                State::AwaitingFutOne =&gt; match self.fut_one.poll(..) {
                    Poll::Ready(()) =&gt; self.state = State::AwaitingFutTwo,
                    Poll::Pending =&gt; return Poll::Pending,
                }
                State::AwaitingFutTwo =&gt; match self.fut_two.poll(..) {
                    Poll::Ready(()) =&gt; self.state = State::Done,
                    Poll::Pending =&gt; return Poll::Pending,
                }
                State::Done =&gt; return Poll::Ready(()),
            }
        }
    }
}
</code></pre>
<p><code>poll</code>이 처음 호출되면 <code>poll</code>은 <code>fut_one</code>을 poll할 것입니다. 만약 <code>fut_one</code>이
완성될 수 없다면, <code>AsyncFuture::poll</code>은 <code>Poll::Pending</code>을 반환하며 종료될
것입니다. future에 대한 <code>poll</code> 호출들은 이전에 중단된 지점(역주: <code>self.state</code>를
<code>match</code>하여)부터 다시 시작할 것입니다(TODO: 재번역 필요). 이 과정은 future가
성공적으로 완성될 때까지 반복될 것입니다.</p>
<p>하지만, <code>async</code> 블록이 참조를 사용한다면 어떻게 될까요?</p>
<p>예를 들어:</p>
<pre><code class="language-rust edition2018 ignore">async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&amp;mut x);
    read_into_buf_fut.await;
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p>위 코드는 어떤 구조체로 변환될까요?</p>
<pre><code class="language-rust ignore">struct ReadIntoBuf&lt;'a&gt; {
    buf: &amp;'a mut [u8], // 아래 `x`를 가리킴
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf&lt;'what_lifetime?&gt;,
}
</code></pre>
<p>여기 <code>ReadIntoBuf</code> future는 우리 구조체의 다른 필드인 <code>x</code>를 가리키는 참조를
가지고 있습니다. 따라서, <code>AsyncFuture</code>가 옮겨진다면, <code>x</code>의 위치도 같이 움직이면서 
<code>read_into_buf_fut.buf</code>에 저장된 포인터도 무효화 될 것입니다.</p>
<p>future를 특정된 메모리 위치에 고정함으로서 이 문제를 방지하고, <code>async</code> 블록 안에
있는 값에 대한 참조를 안전하게 만들 수 있습니다.</p>
<h2><a class="header" href="#고정하기에-대한-상세설명" id="고정하기에-대한-상세설명">고정하기에 대한 상세설명</a></h2>
<p>조금 더 간단한 예제로 고정하기를 이해해 봅시다. 위의 문제의 핵심은 '러스트에서
자기참조 타입의 참조를 어떻게 다루는가'입니다.</p>
<p>지금부터 우리의 예제는 다음과 같이 바뀔 겁니다.</p>
<pre><code class="language-rust ignore">use std::pin::Pin;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&amp;mut self) {
        let self_ref: *const String = &amp;self.a;
        self.b = self_ref;
    }

    fn a(&amp;self) -&gt; &amp;str {
        &amp;self.a
    }

    fn b(&amp;self) -&gt; &amp;String {
        unsafe {&amp;*(self.b)}
    }
}
</code></pre>
<p><code>Test</code>는 <code>a</code>와 <code>b</code> 필드의 값에 대한 참조를 얻는 메소드를 제공합니다. <code>b</code>는 <code>a</code>에
대한 참조이기 때문에 <code>b</code>에 포인터를 사용합니다. 왜냐하면, 러스트의 빌림규칙에
따라 이 라이프타임을 정의할 수 없기 때문입니다. 이 구조체가 바로 자기-참조
구조체라고 불리는 것입니다.</p>
<p>아래 예제를 실행하면 알 수 있듯이, 어느 데이타도 여기저기 움직이지 않는다면 위
예제는 잘 작동할 겁니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
<span class="boring">use std::pin::Pin;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // 자기-참조를 실제로 설정할 `init` 메소드
</span><span class="boring">    fn init(&amp;mut self) {
</span><span class="boring">        let self_ref: *const String = &amp;self.a;
</span><span class="boring">        self.b = self_ref;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b(&amp;self) -&gt; &amp;String {
</span><span class="boring">        unsafe {&amp;*(self.b)}
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>예상한 대로 출력됩니다.</p>
<pre><code class="language-rust ignore">a: test1, b: test1
a: test2, b: test2
</code></pre>
<p>그럼 <code>test1</code>과 <code>test2</code>를 스왑하여 데이터를 움직여보고, 무슨 일이 생기는 지 봅시다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
<span class="boring">use std::pin::Pin;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn init(&amp;mut self) {
</span><span class="boring">        let self_ref: *const String = &amp;self.a;
</span><span class="boring">        self.b = self_ref;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b(&amp;self) -&gt; &amp;String {
</span><span class="boring">        unsafe {&amp;*(self.b)}
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>단순하게 생각하면, 아래처럼 두 번 다 <code>test1</code>의 디버그 내용이 출력될 것이라
생각하기 십상입니다:</p>
<pre><code class="language-rust ignore">a: test1, b: test1
a: test1, b: test1
</code></pre>
<p>하지만 실제 출력은 다음과 같습니다:</p>
<pre><code class="language-rust ignore">a: test1, b: test1
a: test1, b: test2
</code></pre>
<p>스왑 이후에도, <code>test2.b</code>에 대한 포인터는 여전히 지금 <code>test1</code> 내부에 있는 옛
위치를 가리킵니다.(TODO: 의역으로 재번역) 이 구조체는 더 이상 자기-참조적이지
않으며, 다른 객체 안에 있는 필드를 가리키는 포인터를 가지게 됩니다. 즉,
<code>test2</code>의 라이프타임에 매여있는 <code>test2.b</code>의 라이프타임을 더이상 신뢰할 수 없다는
뜻입니다.</p>
<p>만약 아직도 이해가 되지 않는다면, 아래 코드가 확실히 이해시켜 줄 것입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    test1.init();
    let mut test2 = Test::new(&quot;test2&quot;);
    test2.init();

    println!(&quot;a: {}, b: {}&quot;, test1.a(), test1.b());
    std::mem::swap(&amp;mut test1, &amp;mut test2);
    test1.a = &quot;I've totally changed now!&quot;.to_string();
    println!(&quot;a: {}, b: {}&quot;, test2.a(), test2.b());

}
<span class="boring">use std::pin::Pin;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn init(&amp;mut self) {
</span><span class="boring">        let self_ref: *const String = &amp;self.a;
</span><span class="boring">        self.b = self_ref;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b(&amp;self) -&gt; &amp;String {
</span><span class="boring">        unsafe {&amp;*(self.b)}
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>아래 그림은 이 내용들을 도식화합니다.</p>
<p><strong>Fig 1: 스왑 전 후</strong>
<img src="04_pinning/../assets/swap_problem.jpg" alt="swap_problem" /></p>
<p>다른 특별한 방법도 있겠지만, 그림으로 정의되지 않은 동작과 실패를 표현하면
이해하기 쉽습니다.</p>
<h2><a class="header" href="#실전에서-고정하기" id="실전에서-고정하기">실전에서 고정하기</a></h2>
<p>고정하기와 <code>Pin</code> 타입으로 이 문제를 해결하는지 알아봅시다.</p>
<p><code>Pin</code> 타입은 포인터를 감싸서 포인터 뒤에 있는 값이 움직이지 않음을 보장해줍니다.
예를 들어, <code>Pin&lt;&amp;mut T&gt;</code>, <code>Pin&lt;&amp;T&gt;</code>, <code>Pin&lt;Box&lt;T&gt;&gt;</code>들은 모두 <code>T: !Unpin</code>이라면
<code>T</code>가 움직이지 않음을 보장합니다.</p>
<p>대부분의 타입들에게는 이동되는 문제점이 없습니다. 이러한 타입들은 <code>Unpin</code>이라는
트레잇을 구현합니다. <code>Unpin</code> 타입에 대한 포인터들은 자유롭게 <code>Pin</code> 안에 넣거나
꺼낼 수 있습니다. 예를 들어, <code>u8</code>은 <code>Unpin</code>이어서 <code>Pin&lt;&amp;mut u8&gt;</code>은 그냥 평범한
<code>&amp;mut u8</code>처럼 작동합니다.</p>
<p>하지만, 고정된 다음에는 움직일 수 없는 타입들은 <code>!Unpin</code>이라는 마커를 가지고
있습니다. async/await에 의해 만들어진 future들이 그 예시입니다.</p>
<h3><a class="header" href="#스택에-고정하기" id="스택에-고정하기">스택에 고정하기</a></h3>
<p>다시 예제로 돌아가서, <code>Pin</code>을 이용하여 문제를 해결할 수 있습니다. 고정된
포인터를 사용하면 우리의 예제가 어떻게 바뀌는지 살펴봅시다.(TODO: 검토)</p>
<pre><code class="language-rust ignore">use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &amp;str) -&gt; Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }
    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
        let self_ptr: *const String = &amp;self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        unsafe { &amp;*(self.b) }
    }
}
</code></pre>
<p>우리의 타입이 <code>!Unpin</code>을 구현한다면 객체를 스택에 고정하는 것은 항상 <code>unsafe</code>할
것입니다. 여러분은 스택에 고정할 때 <code>unsafe</code> 코드를 직접 사용하지 않으려면
<a href="https://docs.rs/pin-utils/"><code>pin_utils</code></a> 같은 크레잇을 사용할 수 있습니다.</p>
<p>아래처럼, 객체 <code>test1</code>과 <code>test2</code>를 스택에 고정합시다.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    // test1은 초기화되기 전에 움직여도 안전합니다.
    let mut test1 = Test::new(&quot;test1&quot;);
    // `test1`이 다시 액세스되는 것을 막기 위해 어떻게 `test1`을 쉐도우하는지 확인해 두세요
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new(&quot;test2&quot;);
    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut test2) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
<span class="boring">use std::pin::Pin;
</span><span class="boring">use std::marker::PhantomPinned;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">    _marker: PhantomPinned,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">            // 우리의 타입을 `!Unpin`으로 만듭니다.
</span><span class="boring">            _marker: PhantomPinned,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
</span><span class="boring">        let self_ptr: *const String = &amp;self.a;
</span><span class="boring">        let this = unsafe { self.get_unchecked_mut() };
</span><span class="boring">        this.b = self_ptr;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
</span><span class="boring">        &amp;self.get_ref().a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
</span><span class="boring">        unsafe { &amp;*(self.b) }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>자, 만약 지금 우리가 데이터를 움직이려고 하면, 컴파일 에러가 발생합니다.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">pub fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    let mut test1 = unsafe { Pin::new_unchecked(&amp;mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new(&quot;test2&quot;);
    let mut test2 = unsafe { Pin::new_unchecked(&amp;mut test2) };
    Test::init(test2.as_mut());

    println!(&quot;a: {}, b: {}&quot;, Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!(&quot;a: {}, b: {}&quot;, Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
<span class="boring">use std::pin::Pin;
</span><span class="boring">use std::marker::PhantomPinned;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">    _marker: PhantomPinned,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">            _marker: PhantomPinned, // 우리의 타입을 `!Unpin`으로 만듭니다.
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
</span><span class="boring">        let self_ptr: *const String = &amp;self.a;
</span><span class="boring">        let this = unsafe { self.get_unchecked_mut() };
</span><span class="boring">        this.b = self_ptr;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
</span><span class="boring">        &amp;self.get_ref().a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
</span><span class="boring">        unsafe { &amp;*(self.b) }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>타입 시스템은 우리가 데이터를 움직이지 못하게 막아줍니다.</p>
<blockquote>
<p>스택에 고정하기는 <code>unsafe</code>를 사용하므로 항상 여러분이 보장해야 한다는 점을
명심하세요. <code>&amp;'a mut T</code>가 _가리키는 값_은 <code>'a</code> 라이프타임에 동안 고정된지만,
<code>&amp;'a mut T</code>가 가리키는 데이터가 <code>'a</code>가 끝난 다음에도 움직이지 않았는지 알 수는
없습니다.(TODO: 재번역) 만약 <code>&amp;'a mut T</code>가 가리키는 데이터가 <code>'a</code>가 끝난
다음에 움직인다면 Pin 규칙을 어기게 될 것입니다.</p>
</blockquote>
<blockquote>
<p>원 변수를 쉐도우하는 것을 깜빡하기 쉽습니다. 왜냐하면, (Pin 규칙을 어기는)
아래 코드처럼, <code>Pin</code>을 드랍하고 나서, <code>&amp;'a mut T</code> 다음에 데이타를 움직일
가능성이 있기 때문입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let mut test1 = Test::new(&quot;test1&quot;);
   let mut test1_pin = unsafe { Pin::new_unchecked(&amp;mut test1) };
   Test::init(test1_pin.as_mut());
   drop(test1_pin);
   println!(r#&quot;test1.b points to &quot;test1&quot;: {:?}...&quot;#, test1.b);
   let mut test2 = Test::new(&quot;test2&quot;);
   mem::swap(&amp;mut test1, &amp;mut test2);
   println!(&quot;... and now it points nowhere: {:?}&quot;, test1.b);
}
<span class="boring">use std::pin::Pin;
</span><span class="boring">use std::marker::PhantomPinned;
</span><span class="boring">use std::mem;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Test {
</span><span class="boring">    a: String,
</span><span class="boring">    b: *const String,
</span><span class="boring">    _marker: PhantomPinned,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">impl Test {
</span><span class="boring">    fn new(txt: &amp;str) -&gt; Self {
</span><span class="boring">        Test {
</span><span class="boring">            a: String::from(txt),
</span><span class="boring">            b: std::ptr::null(),
</span><span class="boring">            // This makes our type `!Unpin`
</span><span class="boring">            _marker: PhantomPinned,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    fn init&lt;'a&gt;(self: Pin&lt;&amp;'a mut Self&gt;) {
</span><span class="boring">        let self_ptr: *const String = &amp;self.a;
</span><span class="boring">        let this = unsafe { self.get_unchecked_mut() };
</span><span class="boring">        this.b = self_ptr;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
</span><span class="boring">        &amp;self.get_ref().a
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
</span><span class="boring">        unsafe { &amp;*(self.b) }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
</blockquote>
<h3><a class="header" href="#힙-역역에-고정하기" id="힙-역역에-고정하기">힙 역역에 고정하기</a></h3>
<p><code>!Unpin</code>타입을 힙에 고정하면 우리 데이타에 안정적인 주소를 부여하게 됩니다.
그래서 우리가 가리키는 데이터는 고정되고 나면 움직일 수 없습니다. 스택에
고정하기와 대조적으로, 데이터가 객체의 수명주기동안 고정됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
   a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &amp;str) -&gt; Pin&lt;Box&lt;Self&gt;&gt; {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &amp;boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a str {
        &amp;self.get_ref().a
    }

    fn b&lt;'a&gt;(self: Pin&lt;&amp;'a Self&gt;) -&gt; &amp;'a String {
        unsafe { &amp;*(self.b) }
    }
}

pub fn main() {
    let mut test1 = Test::new(&quot;test1&quot;);
    let mut test2 = Test::new(&quot;test2&quot;);

    println!(&quot;a: {}, b: {}&quot;,test1.as_ref().a(), test1.as_ref().b());
    println!(&quot;a: {}, b: {}&quot;,test2.as_ref().a(), test2.as_ref().b());
}
</code></pre></pre>
<p>몇몇 함수들은 future가 <code>Unpin</code> 타입일 것을 요구합니다. <code>Unpin</code>이 아닌 <code>Future</code>나
<code>Stream</code>을 <code>Unpin</code> 타입을 요구하는 함수와 함께 사용하기 위해서는, 먼저
(<code>Pin&lt;Box&lt;T&gt;&gt;</code>을 만든다면) <code>Box::pin</code>이나 (<code>Pin&lt;&amp;mut T&gt;</code>를 만든다면)
<code>pin_utils::pin_mut!</code> 매크로를 사용하여 값을 고정해야 합니다. <code>Pin&lt;Box&lt;Fut&gt;&gt;</code>와
<code>Pin&lt;&amp;mut Fut&gt;</code> 둘 다 future처럼 사용될 수 있으며, 둘 다 <code>Unpin</code>을 구현합니다.</p>
<p>예를 들어:</p>
<pre><code class="language-rust edition2018 ignore">use pin_utils::pin_mut; // `pin_utils`는 crates.io에 있는 가벼운 crate입니다.

// `Unpin`을 구현하는 `Future`를 취하는 함수
fn execute_unpin_future(x: impl Future&lt;Output = ()&gt; + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // 오류: `fut`은 `Unpin` 트레잇을 구현하지 않음

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
</code></pre>
<h2><a class="header" href="#정리" id="정리">정리</a></h2>
<ol>
<li>
<p><code>T: Unpin</code>(기본값)이라면 <code>Pin&lt;'a, T&gt;</code>는 <code>&amp;'a mut T</code>와 전적으로 동일합니다.
다르게 표현하자면, <code>Unpin</code>은 &quot;이 타입은 고정되었을지라도 움직여도 됨&quot;을
의미합니다. 따라서 <code>Pin</code>은 해당 타입에 대해 효과가 없습니다.</p>
</li>
<li>
<p><code>T: !Unpin</code>일 때, 고정된 T에 대하여 <code>&amp;mut T</code>를 얻으려면 unsafe가 필요합니다.</p>
</li>
<li>
<p>대부분의 표준 라이브러리 타입들은 <code>Unpin</code>을 구현합니다. 여러분이 러스트에서
사용할 대부분의 &quot;평범한&quot; 타입들도 마찬가지입니다. async/await에 의해 생성된
<code>Future</code>는 이 규칙에 예외입니다.</p>
</li>
<li>
<p>nightly에서는 feature flag를 설정하면 어떤 타입을 <code>!Unpin</code>할 수
있습니다(TODO: add bound를 다시 번역). stable에서는 타입에
<code>std::marker::PhantomPinned</code>를 추가하면 됩니다.</p>
</li>
<li>
<p>데이타를 스택이나 힙에 고정할 수 있습니다.</p>
</li>
<li>
<p><code>!Unpin</code> 객체를 스택에 고정하려면 <code>unsafe</code>가 필요합니다.</p>
</li>
<li>
<p><code>!Unpin</code> 객체를 힙에 고정할 때는 <code>unsafe</code>가 필요 없습니다. <code>Box::pin</code>을
사용하면 간단하게 할 수 있습니다.</p>
</li>
<li>
<p><code>T: !Unpin</code>인 고정된 데이터에 대해서는, 여러분이 그 데이터의 메모리가
_고정되어 drop이 호출되기 전_까지 무효화되거나 용도변경되지 않음(불변성)을
유지할 책임이 있습니다. 이는 _고정 규칙_에서 중요한 부분입니다.</p>
</li>
</ol>
<h1><a class="header" href="#stream-트레잇" id="stream-트레잇"><code>Stream</code> 트레잇</a></h1>
<p><code>Stream</code> 트레잇은 <code>Future</code>와 비슷하지만 작업을 끝내기 전 여러 값을 양보할 수 있다는 점에서
표준 라이브러리의 <code>Iterator</code> 트레잇과 비슷합니다.</p>
<pre><code class="language-rust ignore">trait Stream {
    /// 스트림이 양보하는 값의 타입
    type Item;

    /// 스트림에 있는 다음 아이템을 해결하려 한다.
    /// 아직 준비가 안 됐으면 `Poll::Pending`, 준비가 되었으면 `Poll::Ready(Some(x))`
    /// , 끝났으면 `Poll::Ready(None)`을 반환한다.
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
</code></pre>
<p><code>Stream</code>의 한 가지 예시로 <code>futures</code> 크레이트에 있고 채널 타입에 쓰이는 <code>Receiver</code>가 있습니다. 
<code>Sender</code>가 값을 보낼 때마다 <code>Some(val)</code>을 내놓고, <code>Sender</code>의 실행을 거부해 끝내지 않은 모든 메시지를 
받을 때 <code>None</code>을 반환합니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn send_recv() {
    const BUFFER_SIZE: usize = 10;
    let (mut tx, mut rx) = mpsc::channel::&lt;i32&gt;(BUFFER_SIZE);

    tx.send(1).await.unwrap();
    tx.send(2).await.unwrap();
    drop(tx);

    // `StreamExt::next` 는 `Iterator::next`와 같지만, 
    // `Future&lt;Output = Option&lt;T&gt;&gt;`을 구현한 타입을 반환합니다.
    assert_eq!(Some(1), rx.next().await);
    assert_eq!(Some(2), rx.next().await);
    assert_eq!(None, rx.next().await);
}
</code></pre>
<h1><a class="header" href="#iteration-and-concurrency" id="iteration-and-concurrency">Iteration and Concurrency</a></h1>
<p>동기적인 <code>Iterator</code>와 같이 <code>Stream</code>에서 값을 반복하고 처리하는 여러 가지 방법이 있습니다.
<code>map</code>, <code>filter</code>, <code>fold</code>와 같은 콤비네이터 방식과 <code>try_map</code>, <code>try_filter</code>, <code>try_fold</code>와 
같이 오류가 생기면 바로 종료하는 방식의 메소드가 있습니다.</p>
<p>슬프게도 <code>for</code> 반복문은 <code>Stream</code>과 같이 사용할 수 없지만, 명령형 코드를 위해 
<code>while let</code>과 <code>next</code>/<code>try_next</code> 함수를 쓸 수 있습니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn sum_with_next(mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = i32&gt;&gt;) -&gt; i32 {
    use futures::stream::StreamExt; // `next`를 쓰기 위함
    let mut sum = 0;
    while let Some(item) = stream.next().await {
        sum += item;
    }
    sum
}

async fn sum_with_try_next(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;i32, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;i32, io::Error&gt; {
    use futures::stream::TryStreamExt; // `try_next`를 쓰기 위함
    let mut sum = 0;
    while let Some(item) = stream.try_next().await? {
        sum += item;
    }
    Ok(sum)
}
</code></pre>
<p>하지만 우리가 단지 한 시간마다 한 요소만 처리하고 있다면 잠재적으로 동시성의 기회를 내다버린 것과 
다를 바 없고, 이것이 결국 처음부터 비동기 코드를 써야 하는 이유로 변합니다. 한 스트림 안에서 여러 
아이템을 동시에 다루기 위해 <code>for_each_concurrent</code>와 <code>try_for_each_concurrent</code>를 사용하시기 바랍니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn jump_around(
    mut stream: Pin&lt;&amp;mut dyn Stream&lt;Item = Result&lt;u8, io::Error&gt;&gt;&gt;,
) -&gt; Result&lt;(), io::Error&gt; {
    use futures::stream::TryStreamExt; // `try_for_each_concurrent`를 쓰기 위함
    const MAX_CONCURRENT_JUMPERS: usize = 100;

    stream.try_for_each_concurrent(MAX_CONCURRENT_JUMPERS, |num| async move {
        jump_n_times(num).await?;
        report_n_jumps(num).await?;
        Ok(())
    }).await?;

    Ok(())
}
</code></pre>
<h1><a class="header" href="#여러개의-future를-동시에-실행하기" id="여러개의-future를-동시에-실행하기">여러개의 future를 동시에 실행하기</a></h1>
<p>지금까지, 대부분의 future를 현재의 task를 <code>Future</code>가 완성될 때까지 블록하는
<code>.await</code>로 실행시켰습니다. 그러나, 진짜 비동기 어플리케이션은 종종 몇개의 다른
작업을 동시에 실행할 필요가 있습니다.</p>
<p>이 장에서는 여러개의 비동기 작업들을 동시에 싱행하는 몇가지 방법들을 배울 것입니다.</p>
<ul>
<li><code>join!</code> : future들이 모두 완성될 때까지 기다림</li>
<li><code>select!</code> : 여러 future 중에 한개가 완료될 때까지 기다림</li>
<li>스포닝 : 한 개의 future를 완성될 때까지 주변에서 실행하는 최상위 task를 만듦</li>
<li><code>FuturesUnordered</code> : future들의 그룹. 각각의 하위future의 결과를 산출함</li>
</ul>
<h1><a class="header" href="#join" id="join"><code>join!</code></a></h1>
<p><code>futures::join</code> 매크로는 여러개의 다른 future를 동시에 실행하여 모두 완성될
때까지 기다리게 해줍니다.</p>
<h1><a class="header" href="#join-1" id="join-1"><code>join!</code></a></h1>
<p>여러개의 비동기 작업을 진행할 때, 단순하게 <code>.await</code>를 순차적으로 사용하는 식으로
만들기 쉽습니다.</p>
<pre><code class="language-rust edition2018 ignore">async fn get_book_and_music() -&gt; (Book, Music) {
    let book = get_book().await;
    let music = get_music().await;
    (book, music)
}
</code></pre>
<p>그런데, 이렇게 하면 필요한 만큼 성능을 낼 수 없습니다. 왜냐하면, <code>get_book</code>이
완성될 때까지 <code>get_music</code>을 시작하려 하지 않을 것이기 때문입니다. 몇몇 다른
언어에서는, future가 완성될 때까지 주변적으로(ambiently) 실행되는 방식을
사용하기도 합니다. 이 방식에서는 처음부터 각 <code>async fn</code>을 호출하여 future들을
시작하고, 둘 모두를 기다림으로써, 두 작업이 동시에 실행될 수 있습니다.</p>
<pre><code class="language-rust edition2018 ignore">// WRONG -- 따라하지 마시오
async fn get_book_and_music() -&gt; (Book, Music) {
    let book_future = get_book();
    let music_future = get_music();
    (book_future.await, music_future.await)
}
</code></pre>
<p>하지만, 실제 러스트의 future는 <code>.await</code>될 때까지 아무것도 하지 않습니다. 따라서,
위의 두 코드 스니펫들은 둘 다 <code>book_future</code>와 <code>music_future</code>를 동시가 아닌
순차적으로 실행한다는 의미입니다. 두 future를 진짜 동시에 실행하려면
<code>futures::join!</code>을 사용하세요:</p>
<pre><code class="language-rust edition2018 ignore">use futures::join;

async fn get_book_and_music() -&gt; (Book, Music) {
    let book_fut = get_book();
    let music_fut = get_music();
    join!(book_fut, music_fut)
}
</code></pre>
<p><code>join!</code>이 반환한 값은 각 <code>Future</code>가 출력한 값으로 구성된 튜플입니다.</p>
<h2><a class="header" href="#try_join" id="try_join"><code>try_join!</code></a></h2>
<p><code>Result</code>를 반환하는 future들에는 <code>join!</code>말고 <code>try_join!</code>을 사용하는 게 좋습니다.
<code>join!</code>은 모든 하위 future들이 완성되었을 때에만 완성되므로, 하위 future 들 중
하나가 <code>Err</code>을 반환하였더라도 나머지 future들을 계속 처리할 것입니다. </p>
<p><code>join!</code>과 다르게, <code>try_join!</code>은 하위 future 중 하나가 에러를 반환하면 즉시 완성될 것입니다.</p>
<pre><code class="language-rust edition2018 ignore">use futures::try_join;

async fn get_book() -&gt; Result&lt;Book, String&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book();
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
</code></pre>
<p><code>try_join!</code>에 전달된 future들은 모두 같은 타입의 에러를 반환해야 한다는 점을
명심하세요. 에러 타입을 일치시키기 위해 <code>futures::future::TryFutureExt</code> 모듈의
<code>.map_err(|e| ...)</code>과 <code>.err_into()</code> 함수를 사용해 보세요.</p>
<pre><code class="language-rust edition2018 ignore">use futures::{
    future::TryFutureExt,
    try_join,
};

async fn get_book() -&gt; Result&lt;Book, ()&gt; { /* ... */ Ok(Book) }
async fn get_music() -&gt; Result&lt;Music, String&gt; { /* ... */ Ok(Music) }

async fn get_book_and_music() -&gt; Result&lt;(Book, Music), String&gt; {
    let book_fut = get_book().map_err(|()| &quot;Unable to get book&quot;.to_string());
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
</code></pre>
<h1><a class="header" href="#select" id="select"><code>select!</code></a></h1>
<p><code>futures::select</code> 매크로를 사용하면 여러 future를 동시에 실행하면서, 어떤
future라도 완성되면 사용자가 바로 반응할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::FutureExt, // `.fuse()`에 필요
    pin_mut,
    select,
};

async fn task_one() { /* ... */ }
async fn task_two() { /* ... */ }

async fn race_tasks() {
    let t1 = task_one().fuse();
    let t2 = task_two().fuse();

    pin_mut!(t1, t2);

    select! {
        () = t1 =&gt; println!(&quot;task one completed first&quot;),
        () = t2 =&gt; println!(&quot;task two completed first&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>위의 함수는 <code>t1</code>과 <code>t2</code> 둘 다 동시에 실행할 것입니다. 둘 중에 하나가 끝나면,
대응하는 핸들러가 <code>println!</code>을 호출하고, 위 함수는 나머지 task를 완성하지 않고
바로 종료됩니다.</p>
<p><code>select</code>의 기본 문법은 <code>&lt;pattern&gt; = &lt;expression&gt; =&gt; &lt;code&gt;,</code>이고, <code>select</code>에
넣을 future 개수만큼 반복하면 됩니다.</p>
<h2><a class="header" href="#default---와-complete--" id="default---와-complete--"><code>default =&gt; ...</code> 와 <code>complete =&gt; ...</code></a></h2>
<p>또한 <code>select</code>는 <code>default</code>와 <code>complete</code> 분기를 지원합니다.</p>
<p><code>default</code> 분기는 <code>select</code>에 넣어진 future들 중 아무것도 완성되지 않았으면
실행됩니다. 따라서 <code>default</code> 분기가 있는 <code>select</code>는 항상 즉시 반환합니다. 다른
어떤 future도 준비되지 않았으면 <code>defualt</code>가 실행되기 때문입니다.</p>
<p><code>complete</code> 분기는 <code>select</code>에 넣어진 모든 future가 모두 완성되어 더 이상 진행할
일이 없는 경우를 다루기 위해 사용됩니다. <code>complete</code> 분기는 <code>select!</code>를 반복문
안에 넣을 때 유용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{future, select};

async fn count() {
    let mut a_fut = future::ready(4);
    let mut b_fut = future::ready(6);
    let mut total = 0;

    loop {
        select! {
            a = a_fut =&gt; total += a,
            b = b_fut =&gt; total += b,
            complete =&gt; break,
            default =&gt; unreachable!(), // 실행되지 않음(future들은 준비되자마자 완성됨)
        };
    }
    assert_eq!(total, 10);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#interaction-with-unpin-and-fusedfuture" id="interaction-with-unpin-and-fusedfuture">Interaction with <code>Unpin</code> and <code>FusedFuture</code></a></h2>
<h2><a class="header" href="#unpin과-fusedfuture로-소통하기" id="unpin과-fusedfuture로-소통하기"><code>Unpin</code>과 <code>FusedFuture</code>로 소통하기</a></h2>
<p>위 첫 번째 예제에서, 여러분은 두 <code>async fn</code>가 반환한 future에 대해 <code>pin_mut</code>으로
고정하고, <code>.fuse()</code>를 호출해야 한다는 점을 인지했을 겁니다. <code>select</code>안에서
사용된 future들은 <code>Unpin</code>, <code>FusedFuture</code> 트레잇 둘 다 구현해야 하기 때문에, 이
호출들이 필요합니다.</p>
<p><code>select</code>가 사용하는 future는 값으로 전달되지 않고 가변 참조로 전달되기 때문에,
<code>Unpin</code>이 필요합니다. future의 소유권을 취하지 않기 때문에, 미완성된 future는
<code>select</code>를 호출한 다음에도 재사용 할 수 있습니다.</p>
<p>비슷하게, <code>select</code>는 이미 완성된 future를 poll하면 안되기 때문에, <code>FusedFuture</code>
트레잇이 필요합니다. <code>FusedFuture</code>는 future에 의해 구현되며, 자신이 완성되었는지
여부를 추적합니다. <code>FusedFuture</code>는 아직 완성되지 않은 future만 골라서 폴링할 수
있게 해주기 때문에 <code>select</code>를 반복문 안에서 사용할 수 있게 됩니다. 이는 위
예제에서 <code>a_fut</code>이나 <code>b_fut</code>가 반복문 2회차 때에 완성되는 것을 보면 알 수
있습니다. <code>future::ready</code>가 반환한 future가 <code>FusedFuture</code>를 구현하기 때문에,
<code>select</code>가 그 future를 다시 poll하지 못하게 할 수 있습니다.</p>
<p>스트림은 같은 기능을 하는 <code>FusedStream</code> 트레잇을 가지고 있음을 알아두세요.
<code>FusedStream</code> 트레잇을 구현하거나, <code>.fuse()</code>를 사용하여 래핑한 스트림은
<code>.next()</code> / <code>.try_next()</code>을 통해 <code>FusedFuture</code>를 뱉을 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    stream::{Stream, StreamExt, FusedStream},
    select,
};

async fn add_two_streams(
    mut s1: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
    mut s2: impl Stream&lt;Item = u8&gt; + FusedStream + Unpin,
) -&gt; u8 {
    let mut total = 0;

    loop {
        let item = select! {
            x = s1.next() =&gt; x,
            x = s2.next() =&gt; x,
            complete =&gt; break,
        };
        if let Some(next_num) = item {
            total += next_num;
        }
    }

    total
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#concurrent-tasks-in-a-select-loop-with-fuse-and-futuresunordered" id="concurrent-tasks-in-a-select-loop-with-fuse-and-futuresunordered">Concurrent tasks in a <code>select</code> loop with <code>Fuse</code> and <code>FuturesUnordered</code></a></h2>
<h2><a class="header" href="#fuse와-futuresunordered를-이용한-select-루프-내부의-동시성-task" id="fuse와-futuresunordered를-이용한-select-루프-내부의-동시성-task"><code>Fuse</code>와 <code>FuturesUnordered</code>를 이용한 <code>select</code> 루프 내부의 동시성 task</a></h2>
<p><code>Fuse:terminated()</code> 함수는 눈에 잘 띄지는 않지만 유용한 함수입니다. 이 함수는
이미 종료되어 비어있지만, 나중에 필요할 때, 실행할 future를 넣어서 실행할 수 있는
future를 만들어 줍니다.</p>
<p>이 함수는 <code>select</code> 루프가 유효한 동안에 실행될 필요가 있지만 <code>select</code> 루프 자체
안에서 만들어지는 task가 있을 경우 유용합니다.</p>
<p><code>.select_next_some()</code> 함수의 용도에 유의하세요. 이 함수는 스트림이 반환한
<code>Some(_)</code> 값에 대응하는 분기를 실행할 때만 <code>select</code>와 함께 사용될 수 있습니다.
<code>.select_next_some()</code>함수는 <code>None</code>을 무시합니다.(TODO: 이 때, <code>None</code>은
무시됩니다)</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) { /* ... */ }

async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let run_on_new_num_fut = run_on_new_num(starting_num).fuse();
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(run_on_new_num_fut, get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                // 타이머가 경과되었음. 아직 실행되지 않고 있는 future가 있다면,
                // 새 `get_new_num_fut`를 시작
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                // 새 숫자가 도착함-- 새 `run_on_new_num_fut`를 시작하고 예전
                // 것을 드랍함.
                run_on_new_num_fut.set(run_on_new_num(new_num).fuse());
            },
            // `run_on_new_num_fut`를 실행
            () = run_on_new_num_fut =&gt; {},
            // 모든 future가 완성되었다면 패닉. 왜냐하면 `indefinitely`는 값들을
            // 무기한으로 내야(yield) 함
            complete =&gt; panic!(&quot;`interval_timer` completed unexpectedly&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>같은 future의 여러 복사본을 동시에 실행할 필요가 있을 때에는 <code>FuturesUnordered</code>
타입을 사용하세요. 아래 예제는 위 예제랑 비슷하지만, <code>run_on_new_num_fut</code>의
복사본이 생겨도 중단하지 않고 각 복사본을 완성될때까지 실행한다는 점이 다릅니다.
또한, 아래 예제는 <code>run_on_new_num_fut</code>가 반환한 값을 출력할 것입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, FuturesUnordered, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -&gt; u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) -&gt; u8 { /* ... */ 5 }

// `get_new_num`로부터 나온 마지막 숫자를 가지고 `run_on_new_num`를 실행
//
// `get_new_num`은 타이머가 경과될 때마다 즉시 현재 실행중인 `run_on_new_num`을
// 취소하고 새 반환값으로 대체하면서 재시작됨.
async fn run_loop(
    mut interval_timer: impl Stream&lt;Item = ()&gt; + FusedStream + Unpin,
    starting_num: u8,
) {
    let mut run_on_new_num_futs = FuturesUnordered::new();
    run_on_new_num_futs.push(run_on_new_num(starting_num));
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() =&gt; {
                // 타이머 경과됨. 실행중인 `get_new_num_fut`이 없다면 새로
                // 시작함.
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut =&gt; {
                // 새 숫자가 도착함-- 새 `run_on_new_num_fut`를 시작함.
                run_on_new_num_futs.push(run_on_new_num(new_num));
            },
            // `run_on_new_num_futs`를 실행하고 완성된 `run_on_new_num_futs`가
            // 있는 지 확인함
            res = run_on_new_num_futs.select_next_some() =&gt; {
                println!(&quot;run_on_new_num_fut returned {:?}&quot;, res);
            },
            // 모든 것이 완성되었다면 패닉. 왜냐하면 `interval_timer`는 값을 무기한으로 내야 함
            complete =&gt; panic!(&quot;`interval_timer` completed unexpectedly&quot;),
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#workarounds-to-know-and-love" id="workarounds-to-know-and-love">Workarounds to Know and Love</a></h1>
<p>Rust's <code>async</code> support is still fairly new, and there are a handful of
highly-requested features still under active development, as well
as some subpar diagnostics. This chapter will discuss some common pain
points and explain how to work around them.</p>
<h1><a class="header" href="#-in-async-blocks" id="-in-async-blocks"><code>?</code> in <code>async</code> Blocks</a></h1>
<p>Just as in <code>async fn</code>, it's common to use <code>?</code> inside <code>async</code> blocks.
However, the return type of <code>async</code> blocks isn't explicitly stated.
This can cause the compiler to fail to infer the error type of the
<code>async</code> block.</p>
<p>For example, this code:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyError;
</span><span class="boring">async fn foo() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span><span class="boring">async fn bar() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span>let fut = async {
    foo().await?;
    bar().await?;
    Ok(())
};
<span class="boring">}
</span></code></pre></pre>
<p>will trigger this error:</p>
<pre><code>error[E0282]: type annotations needed
 --&gt; src/main.rs:5:9
  |
4 |     let fut = async {
  |         --- consider giving `fut` a type
5 |         foo().await?;
  |         ^^^^^^^^^^^^ cannot infer type
</code></pre>
<p>Unfortunately, there's currently no way to &quot;give <code>fut</code> a type&quot;, nor a way
to explicitly specify the return type of an <code>async</code> block.
To work around this, use the &quot;turbofish&quot; operator to supply the success and
error types for the <code>async</code> block:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct MyError;
</span><span class="boring">async fn foo() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span><span class="boring">async fn bar() -&gt; Result&lt;(), MyError&gt; { Ok(()) }
</span>let fut = async {
    foo().await?;
    bar().await?;
    Ok::&lt;(), MyError&gt;(()) // &lt;- note the explicit type annotation here
};
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#send-approximation" id="send-approximation"><code>Send</code> Approximation</a></h1>
<p>Some <code>async fn</code> state machines are safe to be sent across threads, while
others are not. Whether or not an <code>async fn</code> <code>Future</code> is <code>Send</code> is determined
by whether a non-<code>Send</code> type is held across an <code>.await</code> point. The compiler
does its best to approximate when values may be held across an <code>.await</code>
point, but this analysis is too conservative in a number of places today.</p>
<p>For example, consider a simple non-<code>Send</code> type, perhaps a type
which contains an <code>Rc</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Default)]
struct NotSend(Rc&lt;()&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>Variables of type <code>NotSend</code> can briefly appear as temporaries in <code>async fn</code>s
even when the resulting <code>Future</code> type returned by the <code>async fn</code> must be <code>Send</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::rc::Rc;
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct NotSend(Rc&lt;()&gt;);
</span>async fn bar() {}
async fn foo() {
    NotSend::default();
    bar().await;
}

fn require_send(_: impl Send) {}

fn main() {
    require_send(foo());
}
</code></pre></pre>
<p>However, if we change <code>foo</code> to store <code>NotSend</code> in a variable, this example no
longer compiles:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::rc::Rc;
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct NotSend(Rc&lt;()&gt;);
</span><span class="boring">async fn bar() {}
</span>async fn foo() {
    let x = NotSend::default();
    bar().await;
}
<span class="boring">fn require_send(_: impl Send) {}
</span><span class="boring">fn main() {
</span><span class="boring">   require_send(foo());
</span><span class="boring">}
</span></code></pre></pre>
<pre><code>error[E0277]: `std::rc::Rc&lt;()&gt;` cannot be sent between threads safely
  --&gt; src/main.rs:15:5
   |
15 |     require_send(foo());
   |     ^^^^^^^^^^^^ `std::rc::Rc&lt;()&gt;` cannot be sent between threads safely
   |
   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc&lt;()&gt;`
   = note: required because it appears within the type `NotSend`
   = note: required because it appears within the type `{NotSend, impl std::future::Future, ()}`
   = note: required because it appears within the type `[static generator@src/main.rs:7:16: 10:2 {NotSend, impl std::future::Future, ()}]`
   = note: required because it appears within the type `std::future::GenFuture&lt;[static generator@src/main.rs:7:16: 10:2 {NotSend, impl std::future::Future, ()}]&gt;`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `impl std::future::Future`
note: required by `require_send`
  --&gt; src/main.rs:12:1
   |
12 | fn require_send(_: impl Send) {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>This error is correct. If we store <code>x</code> into a variable, it won't be dropped
until after the <code>.await</code>, at which point the <code>async fn</code> may be running on
a different thread. Since <code>Rc</code> is not <code>Send</code>, allowing it to travel across
threads would be unsound. One simple solution to this would be to <code>drop</code>
the <code>Rc</code> before the <code>.await</code>, but unfortunately that does not work today.</p>
<p>In order to successfully work around this issue, you may have to introduce
a block scope encapsulating any non-<code>Send</code> variables. This makes it easier
for the compiler to tell that these variables do not live across an
<code>.await</code> point.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use std::rc::Rc;
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct NotSend(Rc&lt;()&gt;);
</span><span class="boring">async fn bar() {}
</span>async fn foo() {
    {
        let x = NotSend::default();
    }
    bar().await;
}
<span class="boring">fn require_send(_: impl Send) {}
</span><span class="boring">fn main() {
</span><span class="boring">   require_send(foo());
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#recursion" id="recursion">Recursion</a></h1>
<p>Internally, <code>async fn</code> creates a state machine type containing each
sub-<code>Future</code> being <code>.await</code>ed. This makes recursive <code>async fn</code>s a little
tricky, since the resulting state machine type has to contain itself:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">async fn step_one() { /* ... */ }
</span><span class="boring">async fn step_two() { /* ... */ }
</span><span class="boring">struct StepOne;
</span><span class="boring">struct StepTwo;
</span>// This function:
async fn foo() {
    step_one().await;
    step_two().await;
}
// generates a type like this:
enum Foo {
    First(StepOne),
    Second(StepTwo),
}

// So this function:
async fn recursive() {
    recursive().await;
    recursive().await;
}

// generates a type like this:
enum Recursive {
    First(Recursive),
    Second(Recursive),
}
<span class="boring">}
</span></code></pre></pre>
<p>This won't work—we've created an infinitely-sized type!
The compiler will complain:</p>
<pre><code>error[E0733]: recursion in an `async fn` requires boxing
 --&gt; src/lib.rs:1:22
  |
1 | async fn recursive() {
  |                      ^ an `async fn` cannot invoke itself directly
  |
  = note: a recursive `async fn` must be rewritten to return a boxed future.
</code></pre>
<p>In order to allow this, we have to introduce an indirection using <code>Box</code>.
Unfortunately, compiler limitations mean that just wrapping the calls to
<code>recursive()</code> in <code>Box::pin</code> isn't enough. To make this work, we have
to make <code>recursive</code> into a non-<code>async</code> function which returns a <code>.boxed()</code>
<code>async</code> block:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::future::{BoxFuture, FutureExt};

fn recursive() -&gt; BoxFuture&lt;'static, ()&gt; {
    async move {
        recursive().await;
        recursive().await;
    }.boxed()
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#async-in-traits" id="async-in-traits"><code>async</code> in Traits</a></h1>
<p>Currently, <code>async fn</code> cannot be used in traits. The reasons for this are
somewhat complex, but there are plans to remove this restriction in the
future.</p>
<p>In the meantime, however, this can be worked around using the
<a href="https://github.com/dtolnay/async-trait">async-trait crate from crates.io</a>.</p>
<p>Note that using these trait methods will result in a heap allocation
per-function-call. This is not a significant cost for the vast majority
of applications, but should be considered when deciding whether to use
this functionality in the public API of a low-level function that is expected
to be called millions of times a second.</p>
<h1><a class="header" href="#final-project-building-a-concurrent-web-server-with-async-rust" id="final-project-building-a-concurrent-web-server-with-async-rust">Final Project: Building a Concurrent Web Server with Async Rust</a></h1>
<p>In this chapter, we'll use asynchronous Rust to modify the Rust book's 
<a href="https://doc.rust-lang.org/book/ch20-01-single-threaded.html">single-threaded web server</a> 
to serve requests concurrently.</p>
<h2><a class="header" href="#recap" id="recap">Recap</a></h2>
<p>Here's what the code looked like at the end of the lesson.</p>
<p><code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    // Listen for incoming TCP connections on localhost port 7878
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    // Block forever, handling each request that arrives at this IP address
    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    // Read the first 1024 bytes of data from the stream
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    // Respond with greetings or a 404,
    // depending on the data in the request
    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };
    let contents = fs::read_to_string(filename).unwrap();

    // Write response back to the stream,
    // and flush the stream to ensure the response is sent back to the client
    let response = format!(&quot;{}{}&quot;, status_line, contents);
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><code>hello.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>404.html</code>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>If you run the server with <code>cargo run</code> and visit <code>127.0.0.1:7878</code> in your browser,
you'll be greeted with a friendly message from Ferris!</p>
<h1><a class="header" href="#running-asynchronous-code" id="running-asynchronous-code">Running Asynchronous Code</a></h1>
<p>An HTTP server should be able to serve multiple clients concurrently;
that is, it should not wait for previous requests to complete before handling the current request.
The book
<a href="https://doc.rust-lang.org/book/ch20-02-multithreaded.html#turning-our-single-threaded-server-into-a-multithreaded-server">solves this problem</a>
by creating a thread pool where each connection is handled on its own thread.
Here, instead of improving throughput by adding threads, we'll achieve the same effect using asynchronous code.</p>
<p>Let's modify <code>handle_connection</code> to return a future by declaring it an <code>async fn</code>:</p>
<pre><code class="language-rust ignore">async fn handle_connection(mut stream: TcpStream) {
    //&lt;-- snip --&gt;
}
</code></pre>
<p>Adding <code>async</code> to the function declaration changes its return type
from the unit type <code>()</code> to a type that implements <code>Future&lt;Output=()&gt;</code>.</p>
<p>If we try to compile this, the compiler warns us that it will not work:</p>
<pre><code class="language-console">$ cargo check
    Checking async-rust v0.1.0 (file:///projects/async-rust)
warning: unused implementer of `std::future::Future` that must be used
  --&gt; src/main.rs:12:9
   |
12 |         handle_connection(stream);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: futures do nothing unless you `.await` or poll them
</code></pre>
<p>Because we haven't <code>await</code>ed or <code>poll</code>ed the result of <code>handle_connection</code>,
it'll never run. If you run the server and visit <code>127.0.0.1:7878</code> in a browser,
you'll see that the connection is refused; our server is not handling requests.</p>
<p>We can't <code>await</code> or <code>poll</code> futures within synchronous code by itself.
We'll need an asynchronous runtime to handle scheduling and running futures to completion.
Please consult the section on choosing a runtime for more information on asynchronous runtimes, executors, and reactors.</p>
<h2><a class="header" href="#adding-an-async-runtime" id="adding-an-async-runtime">Adding an Async Runtime</a></h2>
<p>Here, we'll use an executor from the <code>async-std</code> crate.
The <code>#[async_std::main]</code> attribute from <code>async-std</code> allows us to write an asynchronous main function.
To use it, enable the <code>attributes</code> feature of <code>async-std</code> in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies.async-std]
version = &quot;1.6&quot;
features = [&quot;attributes&quot;]
</code></pre>
<p>As a first step, we'll switch to an asynchronous main function,
and <code>await</code> the future returned by the async version of <code>handle_connection</code>.
Then, we'll test how the server responds.
Here's what that would look like:</p>
<pre><pre class="playground"><code class="language-rust">#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        // Warning: This is not concurrent!
        handle_connection(stream).await;
    }
}
</code></pre></pre>
<p>Now, let's test to see if our server can handle connections concurrently.
Simply making <code>handle_connection</code> asynchronous doesn't mean that the server
can handle multiple connections at the same time, and we'll soon see why.</p>
<p>To illustrate this, let's simulate a slow request.
When a client makes a request to <code>127.0.0.1:7878/sleep</code>,
our server will sleep for 5 seconds:</p>
<pre><code class="language-rust ignore">use async_std::task;

async fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        task::sleep(Duration::from_secs(5)).await;
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };
    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p>This is very similar to the 
<a href="https://doc.rust-lang.org/book/ch20-02-multithreaded.html#simulating-a-slow-request-in-the-current-server-implementation">simulation of a slow request</a>
from the Book, but with one important difference:
we're using the non-blocking function <code>async_std::task::sleep</code> instead of the blocking function <code>std::thread::sleep</code>.
It's important to remember that even if a piece of code is run within an <code>async fn</code> and <code>await</code>ed, it may still block.
To test whether our server handles connections concurrently, we'll need to ensure that <code>handle_connection</code> is non-blocking.</p>
<p>If you run the server, you'll see that a request to <code>127.0.0.1:7878/sleep</code>
will block any other incoming requests for 5 seconds!
This is because there are no other concurrent tasks that can make progress
while we are <code>await</code>ing the result of <code>handle_connection</code>.
In the next section, we'll see how to use async code to handle connections concurrently.</p>
<h1><a class="header" href="#handling-connections-concurrently" id="handling-connections-concurrently">Handling Connections Concurrently</a></h1>
<p>The problem with our code so far is that <code>listener.incoming()</code> is a blocking iterator.
The executor can't run other futures while <code>listener</code> waits on incoming connections,
and we can't handle a new connection until we're done with the previous one.</p>
<p>In order to fix this, we'll transform <code>listener.incoming()</code> from a blocking Iterator
to a non-blocking Stream. Streams are similar to Iterators, but can be consumed asynchronously.
For more information, see the <a href="08_example/../05_streams/01_chapter.html">chapter on Streams</a>.</p>
<p>Let's replace our blocking <code>std::net::TcpListener</code> with the non-blocking <code>async_std::net::TcpListener</code>,
and update our connection handler to accept an <code>async_std::net::TcpStream</code>:</p>
<pre><code class="language-rust ignore">use async_std::prelude::*;

async fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).await.unwrap();

    //&lt;-- snip --&gt;
    stream.write(response.as_bytes()).await.unwrap();
    stream.flush().await.unwrap();
}
</code></pre>
<p>The asynchronous version of <code>TcpListener</code> implements the <code>Stream</code> trait for <code>listener.incoming()</code>,
a change which provides two benefits.
The first is that <code>listener.incoming()</code> no longer blocks the executor.
The executor can now yield to other pending futures 
while there are no incoming TCP connections to be processed.</p>
<p>The second benefit is that elements from the Stream can optionally be processed concurrently,
using a Stream's <code>for_each_concurrent</code> method.
Here, we'll take advantage of this method to handle each incoming request concurrently.
We'll need to import the <code>Stream</code> trait from the <code>futures</code> crate, so our Cargo.toml now looks like this:</p>
<pre><code class="language-diff">+[dependencies]
+futures = &quot;0.3&quot;

 [dependencies.async-std]
 version = &quot;1.6&quot;
 features = [&quot;attributes&quot;]
</code></pre>
<p>Now, we can handle each connection concurrently by passing <code>handle_connection</code> in through a closure function.
The closure function takes ownership of each <code>TcpStream</code>, and is run as soon as a new <code>TcpStream</code> becomes available.
As long as <code>handle_connection</code> does not block, a slow request will no longer prevent other requests from completing.</p>
<pre><code class="language-rust ignore">use async_std::net::TcpListener;
use async_std::net::TcpStream;
use futures::stream::StreamExt;

#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).await.unwrap();
    listener
        .incoming()
        .for_each_concurrent(/* limit */ None, |tcpstream| async move {
            let tcpstream = tcpstream.unwrap();
            handle_connection(tcpstream).await;
        })
        .await;
}
</code></pre>
<h1><a class="header" href="#serving-requests-in-parallel" id="serving-requests-in-parallel">Serving Requests in Parallel</a></h1>
<p>Our example so far has largely presented concurrency (using async code)
as an alternative to parallelism (using threads).
However, async code and threads are not mutually exclusive.
Async executors can be either single-threaded or multithreaded.
For example, the <a href="https://docs.rs/async-executor"><code>async-executor</code> crate</a> used by <code>async-std</code>
has both a single-threaded <code>LocalExecutor</code> and a multi-threaded <code>Executor</code>.</p>
<p>Tasks can either be run on the thread that created them or on a separate thread.
Async runtimes often provide functionality for spawning tasks onto separate threads.
Even if tasks are executed on separate threads, they should still be non-blocking.</p>
<p>Some runtimes provide functions for spawning blocking tasks onto dedicated threads,
which is useful for running synchronous code from other libraries.
Tasks are usually required to be <code>Send</code>, so they can be moved to separate threads.
Some runtimes also provide functions for spawning non-<code>Send</code> tasks onto a thread-local executor.</p>
<p>In our example, <code>for_each_concurrent</code> processes each connection concurrently on the same thread as the <code>main</code> function.
Here, <code>handle_connection</code> is both <code>Send</code> and non-blocking,
so we could have instead spawned new tasks to run <code>handle_connection</code>.
We can use <code>async_std::task::spawn</code> for this purpose:</p>
<pre><pre class="playground"><code class="language-rust">use async_std::task::spawn;

#[async_std::main]
async fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).await.unwrap();
    listener
        .incoming()
        .for_each_concurrent(/* limit */ None, |stream| async move {
            let stream = stream.unwrap();
            spawn(handle_connection(stream));
        })
        .await;
}
</code></pre></pre>
<p>Now we are using both concurrency and parallelism to handle multiple requests at the same time.</p>
<h1><a class="header" href="#testing-the-tcp-server" id="testing-the-tcp-server">Testing the TCP Server</a></h1>
<p>Let's move on to testing our <code>handle_connection</code> function.</p>
<p>First, we need a <code>TcpStream</code> to work with.
In an end-to-end or integration test, we might want to make a real TCP connection
to test our code.
One strategy for doing this is to start a listener on <code>localhost</code> port 0.
Port 0 isn't a valid UNIX port, but it'll work for testing.
The operating system will pick an open TCP port for us.</p>
<p>Instead, in this example we'll write a unit test for the connection handler,
to check that the correct responses are returned for the respective inputs.
To keep our unit test isolated and deterministic, we'll replace the <code>TcpStream</code> with a mock.</p>
<p>First, we'll change the signature of <code>handle_connection</code> to make it easier to test.
<code>handle_connection</code> doesn't actually require an <code>async_std::net::TcpStream</code>;
it requires any struct that implements <code>async_std::io::Read</code>, <code>async_std::io::Write</code>, and <code>marker::Unpin</code>.
Changing the type signature to reflect this allows us to pass a mock for testing.</p>
<pre><code class="language-rust ignore">use std::marker::Unpin;
use async_std::io::{Read, Write};

async fn handle_connection(mut stream: impl Read + Write + Unpin) {
</code></pre>
<p>Next, let's build a mock <code>TcpStream</code> that implements these traits.
First, let's implement the <code>Read</code> trait, with one method, <code>poll_read</code>.
Our mock <code>TcpStream</code> will contain some data that is copied into the read buffer,
and we'll return <code>Poll::Ready</code> to signify that the read is complete.</p>
<pre><code class="language-rust ignore">    use super::*;
    use futures::io::Error;
    use futures::task::{Context, Poll};

    use std::cmp::min;
    use std::pin::Pin;

    struct MockTcpStream {
        read_data: Vec&lt;u8&gt;,
        write_data: Vec&lt;u8&gt;,
    }

    impl Read for MockTcpStream {
        fn poll_read(
            self: Pin&lt;&amp;mut Self&gt;,
            _: &amp;mut Context,
            buf: &amp;mut [u8],
        ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; {
            let size: usize = min(self.read_data.len(), buf.len());
            buf.copy_from_slice(&amp;self.read_data[..size]);
            Poll::Ready(Ok(size))
        }
    }
</code></pre>
<p>Our implementation of <code>Write</code> is very similar,
although we'll need to write three methods: <code>poll_write</code>, <code>poll_flush</code>, and <code>poll_close</code>.
<code>poll_write</code> will copy any input data into the mock <code>TcpStream</code>, and return <code>Poll::Ready</code> when complete.
No work needs to be done to flush or close the mock <code>TcpStream</code>, so <code>poll_flush</code> and <code>poll_close</code>
can just return <code>Poll::Ready</code>.</p>
<pre><code class="language-rust ignore">    impl Write for MockTcpStream {
        fn poll_write(
            mut self: Pin&lt;&amp;mut Self&gt;,
            _: &amp;mut Context,
            buf: &amp;[u8],
        ) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt; {
            self.write_data = Vec::from(buf);
            return Poll::Ready(Ok(buf.len()));
        }
        fn poll_flush(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt; {
            Poll::Ready(Ok(()))
        }
        fn poll_close(self: Pin&lt;&amp;mut Self&gt;, _: &amp;mut Context) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt; {
            Poll::Ready(Ok(()))
        }
    }
</code></pre>
<p>Lastly, our mock will need to implement <code>Unpin</code>, signifying that its location in memory can safely be moved.
For more information on pinning and the <code>Unpin</code> trait, see the <a href="08_example/../04_pinning/01_chapter.html">section on pinning</a>.</p>
<pre><code class="language-rust ignore">    use std::marker::Unpin;
    impl Unpin for MockTcpStream {}
</code></pre>
<p>Now we're ready to test the <code>handle_connection</code> function.
After setting up the <code>MockTcpStream</code> containing some initial data,
we can run <code>handle_connection</code> using the attribute <code>#[async_std::test]</code>, similarly to how we used <code>#[async_std::main]</code>.
To ensure that <code>handle_connection</code> works as intended, we'll check that the correct data
was written to the <code>MockTcpStream</code> based on its initial contents.</p>
<pre><code class="language-rust ignore">    use std::fs;

    #[async_std::test]
    async fn test_handle_connection() {
        let input_bytes = b&quot;GET / HTTP/1.1\r\n&quot;;
        let mut contents = vec![0u8; 1024];
        contents[..input_bytes.len()].clone_from_slice(input_bytes);
        let mut stream = MockTcpStream {
            read_data: contents,
            write_data: Vec::new(),
        };

        handle_connection(&amp;mut stream).await;
        let mut buf = [0u8; 1024];
        stream.read(&amp;mut buf).await.unwrap();

        let expected_contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
        let expected_response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, expected_contents);
        assert!(stream.write_data.starts_with(expected_response.as_bytes()));
    }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
